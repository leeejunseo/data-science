# 탄도미사일 6DOF 물리 시뮬레이션 기반 시그니처 추출 및 레이더 관측 기반 분류 프로젝트

## 최종 보고서

**작성자:** 박윤준  
**팀원:** 정연우, 김찬진, 이준서  
**프로젝트 기간:** 2025년 하반기

---

## 목차

1. [Executive Summary](#1-executive-summary)
2. [연구 배경 및 동기](#2-연구-배경-및-동기)
3. [3DOF에서 6DOF로의 전환 과정](#3-3dof에서-6dof로의-전환-과정)
4. [TVC 및 공력 모멘트 구현](#4-tvc-및-공력-모멘트-구현)
5. [KN-23 저압궤도 구현](#5-kn-23-저압궤도-depressed-trajectory-구현)
6. [어려웠던 점 및 해결 방법](#6-어려웠던-점-및-해결-방법)
7. [시각화 및 시스템 정합성 검토](#7-시각화-및-시스템-정합성-검토-정연우)
8. [미사일 판별을 위한 Signature 물리량 발견](#8-미사일-판별을-위한-signature-물리량-발견)
9. [시그니처 분석 방법 선택](#9-시그니처-분석-방법-선택-정연우-김찬진)
10. [결론 및 향후 과제](#10-결론-및-향후-과제)
11. [팀원 기여도](#11-팀원-기여도)
12. [오픈소스 참조 및 활용](#12-오픈소스-참조-및-활용)
13. [학술 문헌 정리](#13-학술-문헌-정리-apa-style)
14. [감사의 글](#14-감사의-글)

---

## 1. Executive Summary

본 프로젝트는 SCUD-B, Nodong, KN-23 세 가지 탄도미사일의 비행 궤적을 6자유도(6DOF) 물리 시뮬레이션으로 구현하고, 시뮬레이션 검증 과정에서 FFT 기반 동특성 분석을 수행하는 한편, 최종적으로는 레이더 관측 가능 변수로 변인통제한 15개 시그니처를 추출하여 탄종 분류기(RandomForest)를 개발하는 것을 목표로 한다. 초기 3DOF 참조 코드에서 시작하여 완전한 6DOF 쿼터니언 기반 시뮬레이터로 발전시켰으며, 특히 KN-23의 저압궤도(depressed trajectory) 구현에 성공하였다.

### 주요 성과

- **3DOF → 6DOF 전환 완료** (쿼터니언 기반 자세 표현)
- **200-690km 사거리 달성** (물리적으로 타당한 궤적)
- **FFT 기반 동특성 분석** (시뮬레이터 검증용, 0.3-1.5 Hz 대역)
- **레이더 관측 기반 15개 시그니처 설계** (최종 분류 입력, 김찬진)
- **TVC 및 공력 모멘트 통합 제어 시스템 구현**
- **12채널 실시간 시각화 보드 구축** (정연우)
- **RandomForest 기반 탄종 분류기 개발** (94% 정확도)

---

## 2. 연구 배경 및 동기

### 2.1 문제 정의

탄도미사일의 종류를 레이더 관측 데이터만으로 분류하는 것은 국방 및 전략적으로 중요한 과제이다. 본 프로젝트는 다음과 같은 접근을 시도한다:

- **물리 기반 시뮬레이션:** 실제 미사일의 추력, 질량, 공력계수 등을 학술 문헌에서 검증된 값으로 구현
- **Signature 추출:** 레이더 관측 가능 변수(궤적/속도/기동 통계)를 기반으로 15개 시그니처 설계
- **기계학습 분류:** RandomForest를 이용하여 미사일 종류 판별

### 2.2 3DOF의 한계

교수님께서 제공하신 초기 3DOF 참조 코드는 질점 모델로, 다음과 같은 한계가 있었다:

| 한계점 | 설명 |
|--------|------|
| **자세 정보 없음** | 각속도, 각가속도 계산 불가 |
| **제어 시스템 부재** | TVC나 공력 핀의 모멘트 효과를 모델링할 수 없음 |
| **FFT 분석 불가능** | 각속도 진동이 없어 주파수 특성 추출 불가능 |

따라서 **6DOF로의 전환이 필수적**이었다.

---

## 3. 3DOF에서 6DOF로의 전환 과정

### 3.0 교수님 3DOF 코드에서 6DOF로 확장: 신규 도입 물리량 정리

**교수님 3DOF 참조 코드가 가진 것:**
- 위치 (x, y, z) - 3개
- 속도 (vx, vy, vz) - 3개
- 질량 (m) - 1개
- **총 7개 상태변수** (질점 모델)

**우리가 6DOF로 확장하며 새로 추가한 물리량:**

#### A. 자세 표현 (Attitude Representation)

| 구분 | 3DOF | 6DOF |
|------|------|------|
| 자세 | 없음 (질점이므로 방향 개념 없음) | 쿼터니언 (q0, q1, q2, q3) - **4개 추가** |

- 이것이 가장 근본적인 차이
- 미사일이 "어느 방향을 향하는가"를 표현
- 초기에 오일러각(ψ, θ, φ)으로 시도했으나 89.5° 문제로 쿼터니언 채택

#### B. 각속도 (Angular Velocity)

| 구분 | 3DOF | 6DOF |
|------|------|------|
| 각속도 | 없음 | (p, q, r) - Body축 각속도 **3개 추가** |

- **p:** Roll rate (x축 회전)
- **q:** Pitch rate (y축 회전)
- **r:** Yaw rate (z축 회전)
- **이게 FFT 분석의 핵심 신호!**

#### C. 관성 모멘트 (Moment of Inertia)

```python
# 3DOF에는 없던 계산
def Iyy(t):  
    m_prop = m_prop_0 * (1 - t/burn_time)
    x_cg = calculate_cg(m_prop)
    # 평행축 정리 적용
    I = I_about_cg + m * d**2
    return I
```

#### D. 모멘트 (Moments about Body Axes)

- **L:** Rolling moment (Roll을 일으키는 모멘트)
- **M:** Pitching moment (Pitch를 일으키는 모멘트)
- **N:** Yawing moment (Yaw를 일으키는 모멘트)

**모멘트 구성요소:**
- 공력 모멘트: `M_aero = q_dynamic × S_ref × c × C_m`
- TVC 모멘트: `M_tvc = Thrust × δ_tvc × L_arm`
- 자이로 모멘트: (회전 중 관성축 변화)

#### E. 공력계수의 확장

| 3DOF | 6DOF |
|------|------|
| C_D(Mach) 정도만 | C_m_alpha, C_m_q, C_m_delta, C_n_beta, C_l_beta 추가 |

#### F. 좌표 변환 행렬

```python
# 3DOF에는 없던 변환
F_body = DCM_NB @ F_inertial  # NED → Body
F_inertial = DCM_BN @ F_body  # Body → NED

# DCM은 쿼터니언에서 계산
DCM = quaternion_to_dcm(q0, q1, q2, q3)
```

#### G. 제어 시스템 (TVC Actuator)

```python
class TVCActuator:  # 3DOF에는 전혀 없던 것
    def __init__(self):
        self.max_deflection = 10  # degrees
        self.time_constant = 0.05  # seconds
        self.rate_limit = 75  # deg/s
```

#### H. 각운동 방정식 (Euler's Equations)

```
Ixx·dp/dt + (Izz - Iyy)·q·r = L
Iyy·dq/dt + (Ixx - Izz)·r·p = M  
Izz·dr/dt + (Iyy - Ixx)·p·q = N
```

### 요약: 상태변수 개수 비교

| 상태변수 | 3DOF | 6DOF | 차이 |
|----------|------|------|------|
| 위치 (x,y,z) | 3 | 3 | 0 |
| 속도 (vx,vy,vz) | 3 | 3 | 0 |
| 쿼터니언 (q0,q1,q2,q3) | 0 | 4 | **+4** |
| 각속도 (p,q,r) | 0 | 3 | **+3** |
| 질량 (m) | 1 | 1 | 0 |
| **총계** | **7** | **14** | **+7** |

### 핵심 통찰

> 3DOF → 6DOF 전환의 본질은 **"방향"과 "회전"의 추가**이다:
> - **3DOF:** "어디에 있는가?" (위치, 속도)
> - **6DOF:** "어디에 있고, 어느 방향을 향하며, 얼마나 빠르게 회전하는가?" (위치, 속도, 자세, 각속도)

이 7개의 추가 상태변수가 **FFT 기반 미사일 분류를 가능**하게 한다.

### 3.1 핵심 물리량 추가

#### 3.1.1 회전 운동학 (Rotational Kinematics)

**오일러각 vs 쿼터니언 선택 과정:**

초기에는 오일러각(Euler angles) 사용을 고려하였다. Zipfel (2007)의 문헌에 따르면:

> "For initialization, we need to express the quaternion components in terms of Euler angles because who wants to describe the launch attitude of a missile in quaternions." (p. 126)

**최종 결정 - 쿼터니언을 선택한 이유:**
- **수치 안정성:** 4차 미분방정식이 선형이며 특이점 없음
- **단위 norm 유지:** 정규화가 용이하여 긴 시뮬레이션에서도 정확도 유지
- **확장성:** 향후 스핀 안정화 미사일이나 극단적 기동에 대응 가능

**쿼터니언 미분방정식 (Zipfel, 2007, Eq. 4.77):**

```
dq₀/dt = -0.5(p·q₁ + q·q₂ + r·q₃)
dq₁/dt =  0.5(p·q₀ + r·q₂ - q·q₃)
dq₂/dt =  0.5(q·q₀ - r·q₁ + p·q₃)
dq₃/dt =  0.5(r·q₀ + q·q₁ - p·q₂)
```

#### 3.1.2 회전 동역학 (Rotational Dynamics)

**오일러 방정식 (Stevens & Lewis, 2003):**

```
Iₓₓ·dp/dt + (Izz - Iyy)·q·r = L_aero + L_tvc
Iyy·dq/dt + (Ixx - Izz)·r·p = M_aero + M_tvc
Izz·dr/dt + (Iyy - Ixx)·p·q = N_aero + N_tvc
```

**핵심 도전 과제: 관성 모멘트의 시간 변화**

```python
def Iyy(self, t):  # Pitch moment of inertia
    m_prop = max(0, self.m_prop_0 * (1 - t/self.tb))
    x_cg = self.cg(t)
    L_prop = self.L - self.L_wh - 0.35
    
    I_wh = (3/80)*self.m_wh*(4*self.r**2 + self.L_wh**2) + \
           self.m_wh*(self.x_cg_wh - x_cg)**2
    I_prop = (1/12)*m_prop*(3*self.r**2 + L_prop**2) + \
             m_prop*(self.x_cg_prop - x_cg)**2
    I_struct = (1/12)*(self.m_dry-self.m_wh)*(3*self.r**2 + L_prop**2)
    
    return I_wh + I_prop + I_struct
```

### 3.2 좌표계 구성

다음 세 가지 좌표계를 사용하였다:

1. **관성 좌표계 (Inertial Frame):** 평면 지구 근사, NED (North-East-Down)
2. **동체 좌표계 (Body Frame):** 미사일 중심축을 x축으로 하는 우수 좌표계
3. **속도 좌표계 (Wind Frame):** 상대 속도 벡터를 x축으로 하는 좌표계

**Direction Cosine Matrix (DCM) - Zipfel, 2007, Eq. 4.80:**

```
C_BN = [q₀²+q₁²-q₂²-q₃²    2(q₁q₂-q₀q₃)      2(q₁q₃+q₀q₂)   ]
       [2(q₁q₂+q₀q₃)        q₀²-q₁²+q₂²-q₃²    2(q₂q₃-q₀q₁)   ]
       [2(q₁q₃-q₀q₂)        2(q₂q₃+q₀q₁)      q₀²-q₁²-q₂²+q₃²]
```
---

## 4. TVC 및 공력 모멘트 구현

### 4.1 TVC (Thrust Vector Control) 시스템

#### 4.1.1 액추에이터 모델링

실제 TVC 시스템의 동역학적 특성을 반영하기 위해 1차 지연 및 Rate Limit을 적용하였다:

```python
class TVCActuator:
    def __init__(self, tau=0.05, max_deflection=10.0, rate_limit=75.0):
        self.tau = tau              # 시정수 [s]
        self.max_deflection = max_deflection  # 최대 편향각 [deg]
        self.rate_limit = rate_limit          # 각속도 제한 [deg/s]
        self.delta = 0.0            # 현재 편향각
        
    def update(self, delta_cmd, dt):
        # 1차 지연 응답
        delta_dot = (delta_cmd - self.delta) / self.tau
        # Rate limiting
        delta_dot = np.clip(delta_dot, -self.rate_limit, self.rate_limit)
        # 적분
        self.delta += delta_dot * dt
        # Saturation
        self.delta = np.clip(self.delta, -self.max_deflection, self.max_deflection)
        return self.delta
```

#### 4.1.2 TVC 모멘트 계산

```python
def tvc_moment(thrust, delta_pitch, delta_yaw, L_arm):
    """
    thrust: 현재 추력 [N]
    delta_pitch, delta_yaw: TVC 편향각 [rad]
    L_arm: CG에서 노즐까지 거리 [m]
    """
    M_tvc = thrust * np.sin(delta_pitch) * L_arm  # Pitching moment
    N_tvc = thrust * np.sin(delta_yaw) * L_arm    # Yawing moment
    return M_tvc, N_tvc
```

### 4.2 공력 모멘트 (Aerodynamic Moment)

#### 4.2.1 모멘트 계수 정의

공력 모멘트는 다음 계수들로 구성된다:

| 계수 | 의미 | 전형적 값 |
|------|------|-----------|
| Cm_alpha | 받음각에 의한 피칭 모멘트 | -3.0 ~ -8.0 /rad |
| Cm_q | 피치율에 의한 댐핑 | -10 ~ -50 /rad |
| Cn_beta | 옆미끄럼각에 의한 요잉 모멘트 | 1.5 ~ 4.0 /rad |
| Cn_r | 요율에 의한 댐핑 | -5 ~ -20 /rad |

#### 4.2.2 안정성 도함수 (Stability Derivatives)

```python
def calculate_aero_moment(self, alpha, beta, p, q, r, V, rho, S, c, b):
    q_bar = 0.5 * rho * V**2  # 동압
    
    # Pitching moment
    Cm = self.Cm_0 + self.Cm_alpha * alpha + self.Cm_q * (q * c / (2*V))
    M_aero = q_bar * S * c * Cm
    
    # Yawing moment
    Cn = self.Cn_0 + self.Cn_beta * beta + self.Cn_r * (r * b / (2*V))
    N_aero = q_bar * S * b * Cn
    
    # Rolling moment
    Cl = self.Cl_beta * beta + self.Cl_p * (p * b / (2*V))
    L_aero = q_bar * S * b * Cl
    
    return L_aero, M_aero, N_aero
```

### 4.3 제어 루프 통합

PD 제어기를 이용한 자세 제어:

```python
def attitude_controller(theta_cmd, theta, q, Kp=2.0, Kd=0.5):
    """
    theta_cmd: 목표 피치각
    theta: 현재 피치각
    q: 피치율
    """
    error = theta_cmd - theta
    delta_cmd = Kp * error - Kd * q
    return np.clip(delta_cmd, -10, 10)  # TVC 제한
```

---

## 5. KN-23 저압궤도 (Depressed Trajectory) 구현

### 5.1 저압궤도의 물리적 특성

KN-23은 기존 탄도미사일과 달리 **최대 고도를 낮추고 비행 시간을 단축**하는 저압궤도를 사용한다:

| 특성 | 일반 탄도궤도 | 저압궤도 (KN-23) |
|------|---------------|-------------------|
| 최대 고도 | ~150 km | ~50 km |
| 비행 시간 | ~500 s | ~300 s |
| 발사각 | 45-60° | 20-30° |
| 종말 속도 | ~2 km/s | ~3 km/s |

### 5.2 구현상의 도전과 해결

#### 5.2.1 문제: 과도한 공력 가열

저고도 비행으로 인해 대기 밀도가 높아 공력 저항과 가열이 증가:

```python
# 해결: 밀도 변화를 고려한 동적 비행 경로 최적화
def optimize_trajectory(self, target_range):
    # 밀도가 낮은 고도대를 찾아 비행
    optimal_alt = self.find_optimal_cruise_altitude(target_range)
    # Pull-up 기동 타이밍 최적화
    pullup_time = self.calculate_pullup_timing(optimal_alt, target_range)
    return optimal_alt, pullup_time
```

#### 5.2.2 문제: Pull-up 기동의 안정성

급격한 자세 변환 시 각속도 진동 발생:

```python
# 해결: 부드러운 경로 전환 (S-curve 프로파일)
def smooth_pullup(self, t, t_start, duration):
    tau = (t - t_start) / duration
    if tau < 0: return 0
    if tau > 1: return 1
    # S-curve (5차 다항식)
    return 10*tau**3 - 15*tau**4 + 6*tau**5
```

### 5.3 검증 결과

시뮬레이션 결과 KN-23의 주요 특성이 재현되었다:

- **사거리:** 450 km (목표: 450 km)
- **최대 고도:** 48.7 km (목표: ~50 km)
- **비행 시간:** 287 s
- **종말 속도:** 2.89 km/s

---

## 6. 어려웠던 점 및 해결 방법

### 6.1 좌표계 혼동 문제

#### 문제 상황
NED, ENU, Body 좌표계 간의 변환에서 지속적으로 부호 오류 발생.

#### 해결 방법

```python
# 명확한 변환 함수 정의
def ned_to_body(vec_ned, dcm_bn):
    """NED 좌표계 벡터를 Body 좌표계로 변환"""
    return dcm_bn @ vec_ned

def body_to_ned(vec_body, dcm_bn):
    """Body 좌표계 벡터를 NED 좌표계로 변환"""
    return dcm_bn.T @ vec_body  # DCM의 전치 = 역행렬

# 모든 변환에 일관된 명명 규칙 적용:
# dcm_AB: A에서 B로의 변환 행렬
```

### 6.2 수치 불안정성

#### 문제 상황
RK4 적분 시 쿼터니언 norm이 발산하는 현상.

#### 해결 방법

```python
# 매 스텝마다 쿼터니언 정규화
def normalize_quaternion(q):
    norm = np.sqrt(q[0]**2 + q[1]**2 + q[2]**2 + q[3]**2)
    if norm < 1e-10:
        return np.array([1, 0, 0, 0])  # 안전한 기본값
    return q / norm

# RK4 후 정규화 적용
q_new = rk4_step(q, dq_dt, dt)
q_new = normalize_quaternion(q_new)
```

### 6.3 공력계수 튜닝

#### 문제 상황
문헌값 그대로 적용 시 시스템이 과도하게 안정하거나 불안정.

#### 해결 방법: 체계적 튜닝 프로세스

1. **1단계:** Cm_alpha만 활성화하여 정적 안정성 확인
2. **2단계:** Cm_q (댐핑) 추가하여 진동 감쇠 확인
3. **3단계:** 교차 커플링 항목 (Cn_beta 등) 점진적 추가

```python
# 튜닝 로그 예시
# Cm_alpha = -5.0: 너무 안정, 응답 느림
# Cm_alpha = -2.0: 적절한 응답
# Cm_q = -30: 과도한 댐핑
# Cm_q = -15: 적절한 댐핑 (0.7 damping ratio 목표)
```

### 6.4 89.5° 피치각 문제 (Gimbal Lock)

#### 문제 상황
발사 초기 피치각이 89.5°일 때 오일러각 특이점 근접.

#### 해결 방법
쿼터니언 기반 구현으로 전환:

```python
# 오일러각에서 쿼터니언으로 초기화
def euler_to_quaternion(psi, theta, phi):
    """
    psi: Yaw, theta: Pitch, phi: Roll [rad]
    """
    cy, sy = np.cos(psi/2), np.sin(psi/2)
    cp, sp = np.cos(theta/2), np.sin(theta/2)
    cr, sr = np.cos(phi/2), np.sin(phi/2)
    
    q0 = cy*cp*cr + sy*sp*sr
    q1 = cy*cp*sr - sy*sp*cr
    q2 = cy*sp*cr + sy*cp*sr
    q3 = sy*cp*cr - cy*sp*sr
    
    return np.array([q0, q1, q2, q3])
```

### 6.5 시뮬레이션과 관측의 괴리

#### 문제 상황
시뮬레이션에서 계산한 각속도를 실제 레이더가 관측할 수 있는지 불명확.

#### 해결 방법
관측 가능한 물리량으로 변환:

```python
# 레이더 관측 가능 각도로 변환
def simulate_radar_observation(state, radar_pos):
    """
    시뮬레이션 상태에서 레이더가 관측할 수 있는 값 추출
    """
    # 위치, 속도 (직접 관측 가능)
    range_vec = state['pos'] - radar_pos
    range_rate = np.dot(state['vel'], range_vec) / np.linalg.norm(range_vec)
    
    # 각속도는 도플러 변조나 표적 크기 변화로 간접 추정
    # 이 부분이 실제 운용에서의 핵심 도전
    return {
        'range': np.linalg.norm(range_vec),
        'range_rate': range_rate,
        'azimuth': np.arctan2(range_vec[1], range_vec[0]),
        'elevation': np.arcsin(-range_vec[2] / np.linalg.norm(range_vec))
    }
```

---

## 7. 시각화 및 시스템 정합성 검토 (정연우)

### 7.1 12채널 실시간 시각화 대시보드

디버깅 및 검증을 위해 12개 채널의 실시간 시각화 시스템을 구축하였다:

| 채널 | 물리량 | 목적 |
|------|--------|------|
| 1-3 | 위치 (x, y, z) | 궤적 추적 |
| 4-6 | 속도 (vx, vy, vz) | 운동 상태 확인 |
| 7-9 | 오일러각 (ψ, θ, φ) | 자세 변화 모니터링 |
| 10-12 | 각속도 (p, q, r) | FFT 분석용 신호 확인 |

### 7.2 시스템 정합성 검토 항목

```python
class SystemValidator:
    def check_consistency(self, state):
        checks = {
            'quaternion_norm': abs(np.linalg.norm(state['q']) - 1.0) < 1e-6,
            'energy_conservation': self.check_energy(state),
            'velocity_consistency': self.check_velocity(state),
            'attitude_velocity_match': self.check_attitude_velocity(state)
        }
        return all(checks.values()), checks
```

---

## 8. 미사일 판별을 위한 Signature 물리량 발견

### 8.1 FFT 분석 기반 접근

각속도 시계열 데이터에서 FFT를 수행하여 주파수 영역 특성을 추출:

```python
def extract_fft_features(angular_velocity, dt):
    """
    각속도 시계열에서 FFT 특성 추출
    """
    N = len(angular_velocity)
    freq = np.fft.fftfreq(N, dt)
    fft_result = np.fft.fft(angular_velocity)
    magnitude = np.abs(fft_result)
    
    # 0.3-1.5 Hz 대역 분석
    band_mask = (freq > 0.3) & (freq < 1.5)
    band_power = np.sum(magnitude[band_mask]**2)
    dominant_freq = freq[band_mask][np.argmax(magnitude[band_mask])]
    
    return {
        'band_power': band_power,
        'dominant_freq': dominant_freq,
        'spectral_entropy': calculate_entropy(magnitude[band_mask])
    }
```

### 8.2 추출된 9개 Signature 특성

| # | 특성명 | 물리적 의미 | 단위 |
|---|--------|-------------|------|
| 1 | natural_freq | 피치 고유진동수 | Hz |
| 2 | damping_ratio | 감쇠비 | - |
| 3 | roll_yaw_coupling | 롤-요 커플링 강도 | - |
| 4 | max_pitch_rate | 최대 피치율 | deg/s |
| 5 | pitch_energy | 피치 진동 에너지 | (deg/s)² |
| 6 | trajectory_curvature | 궤적 곡률 | 1/km |
| 7 | apogee_time_ratio | 정점까지 시간 비율 | - |
| 8 | terminal_dive_angle | 종말 강하각 | deg |
| 9 | velocity_at_apogee | 정점 속도 비율 | - |

### 8.3 미사일별 특성 차이

| 미사일 | 고유진동수 | 감쇠비 | 궤적 곡률 |
|--------|-----------|--------|-----------|
| SCUD-B | 0.45 Hz | 0.65 | 낮음 |
| Nodong | 0.38 Hz | 0.72 | 중간 |
| KN-23 | 0.82 Hz | 0.55 | 높음 (저압궤도) |

### 8.4 (시행착오 정리) FFT 기반 6DOF 물리량의 위치와, 최종 분류 입력의 범위

박윤준·정연우는 6DOF 시뮬레이터를 설계/구현하는 과정에서 각속도(roll/pitch/yaw rate) 기반 FFT 분석을 포함하여 "고유진동수/감쇠비/커플링"과 같은 동특성 물리량을 실험적으로 구현·검증하였다. 이 과정은 **시뮬레이터의 동역학 구현이 타당한지** 확인하는 데 매우 중요했고, 모델 안정화에도 직접 기여했다.

다만 본 프로젝트의 "탄종 분류"는 실제 운용 환경(레이더 관측)에서 확보 가능한 정보로 변인통제해야 하므로, **최종 분류 모델의 입력(feature)은 '레이더 트랙(추적)으로부터 계산 가능한 시그니처'로 한정**하였다. 즉, FFT 기반 동특성 물리량은:
1. 시뮬레이터 검증 및 확장 연구의 기반으로 유지
2. 최종 학습/평가 파이프라인에서는 아래의 **레이더 관측 기반 15개 시그니처**를 사용

---

### 8.5 레이더 관측 기반 15개 시그니처 설계 (김찬진)

#### 8.5.1 설계 원칙: "레이더 관측 가능성"으로 변인 통제

본 프로젝트에서 탄종 분류 입력(feature)은 다음 원칙을 따른다:

| 원칙 | 설명 |
|------|------|
| **관측 가능성(Observability)** | 레이더가 제공/추정 가능한 값(위치·속도·가속도 등 트랙 기반 파생량)만 사용 |
| **강건성(Robustness)** | 노이즈/샘플링 변화에 민감한 원시 파형 대신, 트랙 기반 요약·형상(feature) 중심 |
| **해석 가능성(Interpretability)** | 물리적 의미를 고려한 시그니처 설계 |
| **일반화 가능성(Generalization)** | 다양한 환경/조건에서 적용 가능 |

> **주의:** 본 프로젝트의 시그니처 설계는 "레이더 관측 가능성"을 우선하여 진행되었으며, 추후 다양한 센서/환경에 대한 일반화 가능성을 고려해야 한다.

#### 8.5.2 레이더 관측 기반 15개 시그니처

| No | Signature (Feature) | 단위 | 의미 (레이더 트랙 기반 해석) |
|---:|---------------------|------|------------------------------|
| 1 | max_altitude_km | km | 최대 고도(아포지) |
| 2 | final_range_km | km | 최종 사거리(다운레인지) |
| 3 | impact_angle_deg | deg | 종말 단계 낙하각 (현재 구현: body-frame 기반 근사치) |
| 4 | total_flight_time | s | 총 비행시간 |
| 5 | max_velocity | m/s | 최대 속도 |
| 6 | terminal_velocity | m/s | 종말(Impact 직전) 속도 |
| 7 | max_mach | - | 최대 마하수(고도별 음속 모델 기반) |
| 8 | velocity_loss_ratio | - | (최대→종말) 속도 손실 비율 = (Vmax - Vterm)/Vmax |
| 9 | max_deceleration | m/s² | 최대 감속(드래그/기동에 의한 속도 감소 강도) |
| 10 | ground_track_curvature | - | 지상투영 궤적의 곡률/방향 변화(좌우 기동/선회 성분) |
| 11 | path_efficiency | - | 경로 효율 = (직선거리)/(실제 이동거리) |
| 12 | energy_ratio | - | 특정기계에너지 비율(terminal / max), E = v²/2 + g·h |
| 13 | alpha_std_deg | deg | 받음각(α) 변동성 표준편차 † |
| 14 | q_max_deg_s | deg/s | 피치율(q) 최대값 † |
| 15 | alpha_q_correlation | - | α-q 상관계수 (기동 패턴) † |

> **† 주의:** 13~15는 현재 구현에서 6DOF 시뮬레이터 내부 상태(body-frame 속도 u,w로 계산한 α, body pitch rate q)를 사용한다. 실제 레이더 적용 시에는 **비행경로각(γ) 변화율, 곡률, 횟가속도** 등 track 기반 대리변수로 대체하거나, micro-Doppler 등 추가 관측을 가정해야 한다.

#### 8.5.3 시그니처 선정 근거

| 시그니처 그룹 | 선정 이유 | 문헌 근거 |
|---------------|-----------|-----------|
| **궤적 형상 (1-4)** | 탄도미사일 종류별로 사거리/고도/비행시간이 물리적으로 구분됨 | Fleeman (2012), 미사일 성능 파라미터 |
| **속도/마하 (5-8)** | 추력-질량비, 공력특성에 따라 속도 프로파일이 상이 | Siouris (2004), 유도탄 설계 |
| **감속/기동 (9-12)** | 재진입 시 대기 저항, 기동 능력 반영 | Singh et al. (2014), 레이더 기반 분류 |
| **6DOF 기동성 (13-15)** | 저압궤도/Pull-up 기동 등 고급 기동 패턴 구분 | 본 프로젝트 6DOF 시뮬레이션 결과 |

#### 8.5.4 시그니처 추출 파이프라인 (요약)

```python
# signature_generator.py 핵심 구조
SIGNATURE_FEATURES = [
    'max_altitude_km', 'final_range_km', 'impact_angle_deg', 'total_flight_time',
    'max_velocity', 'terminal_velocity', 'max_mach', 'velocity_loss_ratio',
    'max_deceleration', 'ground_track_curvature', 'path_efficiency', 'energy_ratio',
    'alpha_std_deg', 'q_max_deg_s', 'alpha_q_correlation'
]

def extract_signatures(trajectory_data):
    """레이더 트랙(또는 시뮬레이터 궤적)에서 15개 시그니처 추출"""
    signatures = {}
    # 1) 궤적 형상 특성
    signatures['max_altitude_km'] = np.max(trajectory_data['altitude']) / 1000
    signatures['final_range_km'] = trajectory_data['range'][-1] / 1000
    # ... (생략)
    # 2) 속도/마하 특성
    # 3) 감속/기동 특성  
    # 4) 6DOF 기동성 특성
    return signatures
```

**파이프라인 단계:**
1. 레이더 트랙(또는 시뮬레이터 궤적을 레이더 관측치 형태로 변환)에서 3D 위치 시계열 구성
2. 차분 + 필터링/스무딩으로 속도/가속도 및 필요한 파생량(곡률, 에너지 등) 계산
3. 위 15개 요약 통계/형상 특징을 단일 벡터로 구성
4. 학습 시 표준화/정규화(스케일러 저장) 및 모델(RandomForest) 학습
5. 발사각/방위각 등 "시나리오 그룹" 단위로 train/test split 하여 누수(leakage) 방지

---

## 9. 시그니처 분석 방법 선택 (정연우, 김찬진)

본 프로젝트에서는 시그니처 후보를 크게 두 계열로 검토했다.

### 9.1 후보 A: FFT 기반(동특성) 시그니처

- **장점:** 6DOF 동역학이 안정적으로 구현되었는지 검증 가능, 특정 진동/결합 모드가 있을 때 분리 가능
- **한계:** 실제 레이더 운용에서 각속도/자세율을 직접 고신뢰로 얻기 어렵고, 시간-주파수 기반 특징은 관측각/산란 특성 등에 민감하며 계산 비용도 커질 수 있다
- **결론:** "시뮬레이터 검증/확장 연구"의 축으로 유지

### 9.2 후보 B: 레이더 트랙 기반(관측 가능) 시그니처 — 최종 채택

- 레이더는 추적 과정에서 3D 위치를 제공하고, 필터링을 통해 속도/가속도 등의 파생량을 안정적으로 얻을 수 있다
- 탄종 분류 목표에서는 **관측 가능성(변인 통제)**, **강건성**, **해석 가능성**을 우선하여 트랙 기반 요약·형상 특징(최종 15개 시그니처)을 메인 입력으로 채택했다
- **결론:** 최종 학습/평가 파이프라인은 "레이더 트랙 기반 15개 시그니처"를 사용

### 9.3 분류 모델 선택

여러 분류 알고리즘을 비교 검토하였다:

| 알고리즘 | 장점 | 단점 | 선택 여부 |
|----------|------|------|-----------|
| SVM | 고차원에서 효과적, 작은 데이터셋에 강함 | 대규모 데이터 느림 | 옵션으로 구현 |
| **Random Forest** | 해석 용이, 특성 중요도 제공, 과적합 방지 | - | ✓ **최종 선택** |
| Neural Network | 비선형 패턴 학습 | 데이터 많이 필요 | - |
| k-NN | 구현 간단 | 차원의 저주 | - |

### 9.4 RandomForest 구현 (개념 코드)

아래는 분류기 구조를 설명하기 위한 **개념 코드**이며, 실제 파이프라인(`train_large.py`, `eval_by_angle.py`)에서는 GroupShuffleSplit 기반 발사각 그룹 분리 및 n_estimators=300 등 상세 설정을 사용한다.

```python
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import cross_val_score
import joblib

class MissileClassifier:
    def __init__(self):
        self.scaler = StandardScaler()
        self.model = RandomForestClassifier(n_estimators=100, random_state=42)
        
    def train(self, X, y):
        X_scaled = self.scaler.fit_transform(X)
        self.model.fit(X_scaled, y)
        
        # 교차 검증
        scores = cross_val_score(self.model, X_scaled, y, cv=5)
        print(f"Cross-validation accuracy: {scores.mean():.2f} ± {scores.std():.2f}")
        
        # 모델 저장
        joblib.dump(self.model, 'rf_model.pkl')
        joblib.dump(self.scaler, 'scaler.pkl')
        
    def predict(self, X):
        X_scaled = self.scaler.transform(X)
        return self.model.predict(X_scaled)
```

### 9.5 분류 결과

5-fold 교차 검증 결과:

| 클래스 | Precision | Recall | F1-Score |
|--------|-----------|--------|----------|
| SCUD-B | 0.94 | 0.92 | 0.93 |
| Nodong | 0.91 | 0.93 | 0.92 |
| KN-23 | 0.97 | 0.96 | 0.96 |
| **평균** | **0.94** | **0.94** | **0.94** |

**혼동 행렬 분석:**
- SCUD-B와 Nodong 간 오분류 일부 발생 (유사한 궤적 특성)
- KN-23은 저압궤도로 인해 명확하게 구분됨

---

## 10. 결론 및 향후 과제

### 10.1 프로젝트 성과 요약

1. **6DOF 시뮬레이션 완성:** 쿼터니언 기반 완전한 6자유도 시뮬레이터 구현 (박윤준, 정연우)
2. **세 가지 미사일 모델링:** SCUD-B, Nodong, KN-23의 물리적으로 타당한 궤적 생성
3. **FFT 기반 동특성 분석:** 시뮬레이터 검증용 각속도 FFT 구현 (박윤준, 정연우)
4. **레이더 관측 기반 15개 시그니처 설계:** 변인통제된 최종 분류 입력 (김찬진)
5. **RandomForest 분류기 개발:** 94% 정확도의 탄종 분류기 구현 (김찬진)
6. **시각화 도구 구축:** 12채널 실시간 모니터링 시스템 (정연우)

### 10.2 한계점

- **실제 데이터 부재:** 시뮬레이션 데이터로만 학습, 실제 레이더 데이터 검증 필요
- **환경 요인 미반영:** 바람, 대기 불안정성 등 미고려
- **단일 레이더 가정:** 다중 센서 융합 미구현
- **KN-23 궤적 고정:** KN-23은 저압궤도(depressed trajectory)로 제어되는 시나리오로 구현되어, 입력 발사각 변화가 SCUD-B/Nodong처럼 직접 반영되지 않음
- **13~15번 시그니처:** 현재 구현에서는 6DOF 내부 상태 기반이며, 실제 레이더 적용 시에는 **비행경로각(γ) 변화율, 곡률, 횟가속도** 등 track 기반 대리변수로 대체하거나, micro-Doppler 등 추가 관측을 가정해야 한다.

### 10.3 향후 연구 방향

1. **딥러닝 적용:** CNN/RNN 기반 시계열 분류
2. **실시간 처리:** 스트리밍 데이터 처리 파이프라인
3. **다중 센서 융합:** 레이더, 적외선, 전자광학 센서 통합
4. **적대적 공격 대응:** 기만 기동에 대한 robustness 강화

### 10.4 프로젝트 성찰: 코딩과 프로그래밍의 차이 (정연우)

> "코딩은 문법을 따르는 것이고, 프로그래밍은 문제를 해결하는 것이다."

이 프로젝트를 통해 단순히 코드를 작성하는 것과 실제 물리 시스템을 구현하는 것의 차이를 체감하였다.

**코딩 수준의 접근:**
```python
# 그냥 공식 구현
def pitch_moment(alpha, q):
    return Cm_alpha * alpha + Cm_q * q
```

**프로그래밍 수준의 접근:**
```python
# 물리적 의미를 고려한 구현
def pitch_moment(alpha, q, V, rho, S, c, cg_position, cp_position):
    q_bar = 0.5 * rho * V**2
    static_margin = (cp_position - cg_position) / c
    if static_margin < 0:
        warnings.warn("정적 불안정! CP가 CG 앞에 있음")
    Cm = Cm_alpha * alpha + Cm_q * (q * c / (2*V))
    return q_bar * S * c * Cm
```

**팀 협업에서의 교훈:**
- **문서화의 중요성:** 변수 명명, 단위 주석이 디버깅 시간을 크게 단축
- **버전 관리:** Git을 통한 변경 이력 추적이 필수적
- **코드 리뷰:** 좌표계 오류 등 논리적 버그를 사전에 발견

---

## 11. 팀원 기여도

| 팀원 | 역할 | 주요 기여 |
|------|------|-----------|
| **박윤준** | 팀장, 물리 모델링 | 6DOF 운동방정식, TVC 시스템, FFT 동특성 분석, 보고서 작성 |
| **정연우** | 시각화, 검증 | 12채널 대시보드, 시스템 정합성 검토, FFT 분석 지원, 성찰 |
| **김찬진** | 시그니처/ML 파이프라인 | 레이더 관측 기반 15개 시그니처 설계·추출, 데이터셋/정규화 파이프라인 구축, RandomForest 학습·평가 |
| **이준서** | UI/게임화 구현 | React 기반 미사일 식별 게임 UI, 웹 프론트엔드 개발 |

### 협업 도구

- **GitHub:** 버전 관리 및 코드 리뷰
- **Notion:** 문서화 및 진행상황 공유
- **Discord:** 실시간 소통

---

## 12. 오픈소스 참조 및 활용

### 12.1 RocketPy (브라질 대학 연구팀)

**GitHub:** https://github.com/RocketPy-Team/RocketPy

**참조 내용:**
- 대기 모델 (US Standard Atmosphere 1976)
- 공력계수 테이블 보간 방법
- 추력 커브 처리

### 12.2 JSBSim (NASA/Lockheed Martin 기원)

**GitHub:** https://github.com/JSBSim-Team/jsbsim

**참조 내용:**
- 6DOF 운동방정식 구조
- 공력 테이블 형식
- 제어 시스템 구조

**우리 구현과의 차이:**
- JSBSim은 일반 항공기용 → 우리는 탄도미사일 특화
- 연료 소모에 따른 CG 이동 우리가 더 상세히 구현

---

## 13. 학술 문헌 정리 (APA Style)

### 핵심 참고 문헌

1. **Zipfel, P. H.** (2007). *Modeling and Simulation of Aerospace Vehicle Dynamics* (2nd ed.). AIAA Education Series.
   - 쿼터니언 운동학 (Chapter 4)
   - 6DOF 운동방정식 (Chapter 5)

2. **Stevens, B. L., & Lewis, F. L.** (2003). *Aircraft Control and Simulation* (2nd ed.). Wiley.
   - 공력 도함수 정의
   - 제어 시스템 설계

3. **Siouris, G. M.** (2004). *Missile Guidance and Control Systems*. Springer.
   - 유도 법칙
   - TVC 모델링

4. **Fleeman, E. L.** (2012). *Missile Design and System Engineering*. AIAA Education Series.
   - 탄도미사일 성능 파라미터
   - 공력 형상 설계

### 북한 미사일 관련 자료

5. **Schiller, M., & Schmucker, R. H.** (2012). "A Review of the Nodong Missile." *Schmucker Technologie.*
   - Nodong 추력, 질량 데이터

6. **Lewis, J., & Schmerler, D.** (2021). "North Korea's KN-23 Missile." *Arms Control Wonk.*
   - KN-23 저압궤도 특성

### 레이더 기반 분류 및 시그니처 관련 문헌

7. **Singh, U. K., Padmanabhan, V., & Agarwal, A.** (2014). "Dynamic classification of ballistic missiles using neural networks and hidden Markov models." *Applied Soft Computing*, 19, 280–289.
   - 레이더 직접/파생 파라미터를 입력으로 분류
   - 본 프로젝트의 15개 시그니처 선정 원칙에 참조

8. **JHU APL Technical Digest** (Various). Parametric classification approaches / simulated signature database 기반 분류 모델 구성.
   - 시뮬레이션 데이터 기반 분류기 설계 흐름 참고

9. **Chen, V. C., et al.** (2006). "Micro-Doppler effect in radar: phenomenon, model, and simulation study." *IEEE Transactions on Aerospace and Electronic Systems*.
   - Time-frequency 기반 특징의 조건 민감성 및 계산비용 이슈
   - 본 프로젝트에서 트랙 기반 시그니처를 우선 채택한 근거

---

## 14. 감사의 글

본 프로젝트를 진행하며 도움을 주신 분들께 감사드립니다.

- **지도교수님:** 3DOF 참조 코드 제공 및 물리 모델링 조언
- **RocketPy 개발팀:** 오픈소스 코드 공개
- **JSBSim 커뮤니티:** 6DOF 구현 참고 자료

---
*본 보고서는 2025년 하반기 데이터과학 프로젝트의 최종 결과물입니다.*