# 탄도미사일 6DOF 물리 시뮬레이션 기반 시그니처 추출 및 레이더 관측 기반 분류 프로젝트

## 최종 보고서

**작성자:** 박윤준  
**팀원:** 정연우, 김찬진, 이준서  
**프로젝트 기간:** 2025년 하반기

---

## 목차

1. [Executive Summary](#1-executive-summary)
2. [연구 배경 및 동기](#2-연구-배경-및-동기)
3. [3DOF에서 6DOF로의 전환 과정](#3-3dof에서-6dof로의-전환-과정)
4. [TVC 및 공력 모멘트 구현](#4-tvc-및-공력-모멘트-구현)
5. [KN-23 저압궤도 구현](#5-kn-23-저압궤도-depressed-trajectory-구현)
6. [어려웠던 점 및 해결 방법](#6-어려웠던-점-및-해결-방법)
7. [시각화 및 시스템 정합성 검토](#7-시각화-및-시스템-정합성-검토-정연우)
8. [미사일 판별을 위한 Signature 물리량 발견](#8-미사일-판별을-위한-signature-물리량-발견)
9. [시그니처 분석 방법 선택](#9-시그니처-분석-방법-선택-정연우-김찬진)
10. [결론 및 향후 과제](#10-결론-및-향후-과제)
11. [팀원 기여도](#11-팀원-기여도)
12. [오픈소스 참조 및 활용](#12-오픈소스-참조-및-활용)
13. [학술 문헌 정리](#13-학술-문헌-정리-apa-style)
14. [감사의 글](#14-감사의-글)

---

## 1. Executive Summary

본 프로젝트는 SCUD-B, Nodong, KN-23 세 가지 탄도미사일의 비행 궤적을 6자유도(6DOF) 물리 시뮬레이션으로 구현하고, 레이더 관측 가능 변수로 변인통제한 15개 시그니처를 추출하여 RandomForest 기반 탄종 분류기를 개발하는 것을 목표로 한다. 초기 3DOF 참조 코드에서 시작하여 완전한 6DOF 쿼터니언 기반 시뮬레이터로 발전시켰으며, 특히 KN-23의 저압궤도(depressed trajectory) 구현에 성공하였다.

### 주요 성과

- **3DOF → 6DOF 전환 완료** (쿼터니언 기반 자세 표현)
- **200-690km 사거리 달성** (물리적으로 타당한 궤적)
- **레이더 관측 기반 15개 시그니처 설계** (최종 분류 입력, 김찬진)
- **TVC 및 공력 모멘트 통합 제어 시스템 구현**
- **12채널 실시간 시각화 보드 구축** (정연우)
- **RandomForest 기반 탄종 분류기 개발** (발사각 그룹 분리 평가 100% 정확도)

### 시도 및 검증 단계 (최종 분류 입력에서는 제외)

- **FFT 기반 동특성 분석** (시뮬레이터 검증용, 0.3-1.5 Hz 대역) — 6DOF 동역학 구현 타당성 검증에 활용, 최종 분류 입력에서는 제외

---

## 2. 연구 배경 및 동기

### 2.1 문제 정의

탄도미사일의 종류를 레이더 관측 데이터만으로 분류하는 것은 국방 및 전략적으로 중요한 과제이다. 본 프로젝트는 다음과 같은 접근을 시도한다:

- **물리 기반 시뮬레이션:** 실제 미사일의 추력, 질량, 공력계수 등을 학술 문헌에서 검증된 값으로 구현
- **Signature 추출:** 레이더 관측 가능 변수(궤적/속도/기동 통계)를 기반으로 15개 시그니처 설계
- **기계학습 분류:** RandomForest를 이용하여 미사일 종류 판별

### 2.2 3DOF의 한계

교수님께서 제공하신 초기 3DOF 참조 코드는 질점 모델로, 다음과 같은 한계가 있었다:

| 한계점 | 설명 |
|--------|------|
| **자세 정보 없음** | 각속도, 각가속도 계산 불가 |
| **제어 시스템 부재** | TVC나 공력 핀의 모멘트 효과를 모델링할 수 없음 |
| **FFT 분석 불가능** | 각속도 진동이 없어 주파수 특성 추출 불가능 |

따라서 **6DOF로의 전환이 필수적**이었다.

---

## 3. 3DOF에서 6DOF로의 전환 과정

### 3.0 교수님 3DOF 코드에서 6DOF로 확장: 신규 도입 물리량 정리

**교수님 3DOF 참조 코드가 가진 것:**
- 위치 (x, y, z) - 3개
- 속도 (vx, vy, vz) - 3개
- 질량 (m) - 1개
- **총 7개 상태변수** (질점 모델)

**우리가 6DOF로 확장하며 새로 추가한 물리량:**

#### A. 자세 표현 (Attitude Representation)

| 구분 | 3DOF | 6DOF |
|------|------|------|
| 자세 | 없음 (질점이므로 방향 개념 없음) | 쿼터니언 (q0, q1, q2, q3) - **4개 추가** |

- 이것이 가장 근본적인 차이
- 미사일이 "어느 방향을 향하는가"를 표현
- 초기에 오일러각(ψ, θ, φ)으로 시도했으나 89.5° 문제로 쿼터니언 채택

#### B. 각속도 (Angular Velocity)

| 구분 | 3DOF | 6DOF |
|------|------|------|
| 각속도 | 없음 | (p, q, r) - Body축 각속도 **3개 추가** |

- **p:** Roll rate (x축 회전)
- **q:** Pitch rate (y축 회전)
- **r:** Yaw rate (z축 회전)
- **이게 FFT 분석의 핵심 신호!**

#### C. 관성 모멘트 (Moment of Inertia)

```python
# 3DOF에는 없던 계산
def Iyy(t):  
    m_prop = m_prop_0 * (1 - t/burn_time)
    x_cg = calculate_cg(m_prop)
    # 평행축 정리 적용
    I = I_about_cg + m * d**2
    return I
```

#### D. 모멘트 (Moments about Body Axes)

- **L:** Rolling moment (Roll을 일으키는 모멘트)
- **M:** Pitching moment (Pitch를 일으키는 모멘트)
- **N:** Yawing moment (Yaw를 일으키는 모멘트)

**모멘트 구성요소:**
- 공력 모멘트: `M_aero = q_dynamic × S_ref × c × C_m`
- TVC 모멘트: `M_tvc = Thrust × δ_tvc × L_arm`
- 자이로 모멘트: (회전 중 관성축 변화)

#### E. 공력계수의 확장

| 3DOF | 6DOF |
|------|------|
| C_D(Mach) 정도만 | C_m_alpha, C_m_q, C_m_delta, C_n_beta, C_l_beta 추가 |

#### F. 좌표 변환 행렬

```python
# 3DOF에는 없던 변환
F_body = DCM_NB @ F_inertial  # NED → Body
F_inertial = DCM_BN @ F_body  # Body → NED

# DCM은 쿼터니언에서 계산
DCM = quaternion_to_dcm(q0, q1, q2, q3)
```

#### G. 제어 시스템 (TVC Actuator)

```python
class TVCActuator:  # 3DOF에는 전혀 없던 것
    def __init__(self):
        self.max_deflection = 10  # degrees
        self.time_constant = 0.05  # seconds
        self.rate_limit = 75  # deg/s
```

#### H. 각운동 방정식 (Euler's Equations)

```
Ixx·dp/dt + (Izz - Iyy)·q·r = L
Iyy·dq/dt + (Ixx - Izz)·r·p = M  
Izz·dr/dt + (Iyy - Ixx)·p·q = N
```

### 요약: 상태변수 개수 비교

| 상태변수 | 3DOF | 6DOF | 차이 |
|----------|------|------|------|
| 위치 (x,y,z) | 3 | 3 | 0 |
| 속도 (vx,vy,vz) | 3 | 3 | 0 |
| 쿼터니언 (q0,q1,q2,q3) | 0 | 4 | **+4** |
| 각속도 (p,q,r) | 0 | 3 | **+3** |
| 질량 (m) | 1 | 1 | 0 |
| **총계** | **7** | **14** | **+7** |

### 핵심 통찰

> 3DOF → 6DOF 전환의 본질은 **"방향"과 "회전"의 추가**이다:
> - **3DOF:** "어디에 있는가?" (위치, 속도)
> - **6DOF:** "어디에 있고, 어느 방향을 향하며, 얼마나 빠르게 회전하는가?" (위치, 속도, 자세, 각속도)

이 7개의 추가 상태변수가 **FFT 기반 미사일 분류를 가능**하게 한다.

### 3.1 핵심 물리량 추가

#### 3.1.1 회전 운동학 (Rotational Kinematics)

**오일러각 vs 쿼터니언 선택 과정:**

초기에는 오일러각(Euler angles) 사용을 고려하였다. Zipfel (2007)의 문헌에 따르면:

> "For initialization, we need to express the quaternion components in terms of Euler angles because who wants to describe the launch attitude of a missile in quaternions." (p. 126)

**최종 결정 - 쿼터니언을 선택한 이유:**
- **수치 안정성:** 4차 미분방정식이 선형이며 특이점 없음
- **단위 norm 유지:** 정규화가 용이하여 긴 시뮬레이션에서도 정확도 유지
- **확장성:** 향후 스핀 안정화 미사일이나 극단적 기동에 대응 가능

**쿼터니언 미분방정식 (Zipfel, 2007, Eq. 4.77):**

```
dq₀/dt = -0.5(p·q₁ + q·q₂ + r·q₃)
dq₁/dt =  0.5(p·q₀ + r·q₂ - q·q₃)
dq₂/dt =  0.5(q·q₀ - r·q₁ + p·q₃)
dq₃/dt =  0.5(r·q₀ + q·q₁ - p·q₂)
```

#### 3.1.2 회전 동역학 (Rotational Dynamics)

**오일러 방정식 (Stevens & Lewis, 2003):**

```
Iₓₓ·dp/dt + (Izz - Iyy)·q·r = L_aero + L_tvc
Iyy·dq/dt + (Ixx - Izz)·r·p = M_aero + M_tvc
Izz·dr/dt + (Iyy - Ixx)·p·q = N_aero + N_tvc
```

**핵심 도전 과제: 관성 모멘트의 시간 변화**

```python
def Iyy(self, t):  # Pitch moment of inertia
    m_prop = max(0, self.m_prop_0 * (1 - t/self.tb))
    x_cg = self.cg(t)
    L_prop = self.L - self.L_wh - 0.35
    
    I_wh = (3/80)*self.m_wh*(4*self.r**2 + self.L_wh**2) + \
           self.m_wh*(self.x_cg_wh - x_cg)**2
    I_prop = (1/12)*m_prop*(3*self.r**2 + L_prop**2) + \
             m_prop*(self.x_cg_prop - x_cg)**2
    I_struct = (1/12)*(self.m_dry-self.m_wh)*(3*self.r**2 + L_prop**2)
    
    return I_wh + I_prop + I_struct
```

### 3.2 좌표계 구성: 왜 세 가지 좌표계가 필요한가?

6DOF 시뮬레이션에서는 **서로 다른 물리량이 서로 다른 좌표계에서 자연스럽게 표현**된다. 이를 하나의 좌표계로 통일하지 않으면 운동방정식을 풀 수 없다.

#### 3.2.1 문제 상황: 물리량마다 선호하는 좌표계가 다르다

**예시**:
```
중력 g: "지구 중심을 향한다" → 관성 좌표계(NED)에서 자연스러움
추력 T: "미사일 앞쪽으로 향한다" → 동체 좌표계(Body)에서 자연스러움
항력 D: "속도 반대 방향" → 속도 좌표계(Wind)에서 자연스러움
```

만약 모든 힘을 같은 좌표계로 표현하지 않으면:
```python
# ❌ 틀린 코드 (좌표계 혼합)
F_total = g_NED + T_Body + D_Wind  # 차원 불일치!
```

**해결책**: 좌표 변환 행렬(DCM)로 모두 하나의 좌표계로 통일!

#### 3.2.2 세 가지 좌표계 정의 및 용도

본 프로젝트는 다음 세 좌표계를 사용한다:

---

**1. 관성 좌표계 (Inertial Frame) - NED**
```
              N (North, 북쪽)
              ↑
              |
    W --------●-------- E (East, 동쪽)
              |
              ↓
              D (Down, 지구 중심)
```

**정의**: 
- **원점**: 발사 지점 (고정)
- **1축 (North)**: 북쪽 방향 (수평)
- **2축 (East)**: 동쪽 방향 (수평)
- **3축 (Down)**: 지구 중심 방향 (수직 아래)

**용도**:
```python
# 1. 중력 (항상 Down 방향)
g_NED = [0, 0, 9.80665]  # m/s²

# 2. 위치 추적 (발사점 기준)
position_NED = [x_north, y_east, z_down]

# 3. 궤적 가시화
plt.plot(position_NED[0], position_NED[1])  # 평면 투영
```

**왜 NED인가?**
- **항공우주 표준**: Stevens & Lewis (2003), Zipfel (2007) 모두 NED 사용
- **직관적**: 지도와 일치 (북쪽=위, 동쪽=오른쪽)
- **중력 양수**: g = +9.81 (아래 방향이므로)

**대안: ENU (East-North-Up)**
- 로봇공학에서 선호 (Up이 양수)
- 본 프로젝트는 **항공우주 관례에 따라 NED 선택**

---

**2. 동체 좌표계 (Body Frame) - FRD**
```
        1_B (Forward, 기수 방향)
        ↑
        |     3_B (Down, 배 방향)
        |    ↙
    ----●---- 2_B (Right, 우익 방향)
   (미사일 무게중심 CG)
```

**정의**:
- **원점**: 미사일 무게중심 (CG, 시간에 따라 이동!)
- **1축 (Forward)**: 미사일 기수(nose) 방향
- **2축 (Right)**: 오른쪽 날개 방향
- **3축 (Down)**: 배(belly) 방향

**용도**:
```python
# 1. 추력 (항상 Forward 방향)
thrust_Body = [T, 0, 0]  # N

# 2. 관성 모멘트 (Body축 기준)
I_Body = diag([I_xx, I_yy, I_zz])

# 3. 각속도 (Body축 회전율)
omega_Body = [p, q, r]  # rad/s
# p: Roll rate (Forward축 회전)
# q: Pitch rate (Right축 회전)
# r: Yaw rate (Down축 회전)

# 4. TVC 모멘트
M_TVC_Body = thrust × delta_pitch × L_arm
```

**왜 Body 좌표계가 필요한가?**

만약 추력을 NED로 표현하려면:
```python
# ❌ 복잡함!
theta = pitch_angle(t)
psi = yaw_angle(t)
T_NED = [T*cos(theta)*cos(psi), 
         T*cos(theta)*sin(psi), 
         -T*sin(theta)]  # 매 순간 계산 필요!
```

Body 좌표계 사용:
```python
# ✅ 간단함!
T_Body = [T, 0, 0]  # 항상 이 값!
T_NED = DCM_NB @ T_Body  # 한 번만 변환
```

---

**3. 속도 좌표계 (Wind Frame)**
```
     1_W (대기속도 방향)
     ↑ V_rel
     |
 ----●---- 2_W (횡방향)
     |
     ↓ 3_W (양력 방향)
```

**정의**:
- **원점**: 미사일 무게중심 (Body와 동일)
- **1축**: 대기 상대속도 방향
- **2축**: 1축과 3축에 수직
- **3축**: 양력이 작용하는 평면

**용도**:
```python
# 1. 공력 (항상 속도 기준)
D = -0.5 * rho * V² * S * C_D  # 항력 (1_W 반대)
L = 0.5 * rho * V² * S * C_L   # 양력 (3_W 방향)

F_Wind = [-D, 0, -L]  # Wind 좌표계

# 2. 받음각 정의
alpha = arctan(w_Body / u_Body)  # Body → Wind 변환각
beta = arcsin(v_Body / V_total)   # 옆미끄럼각
```

**왜 Wind 좌표계가 필요한가?**

공력은 **속도에 대해 정의**된다:
- 항력 D: 속도 **반대** 방향
- 양력 L: 속도에 **수직**

만약 Body 좌표계로 표현하면:
```python
# ❌ 복잡함!
alpha = angle_of_attack(t)
D_Body = [-D*cos(alpha), 0, -D*sin(alpha)]
L_Body = [L*sin(alpha), 0, -L*cos(alpha)]
```

Wind 좌표계 사용:
```python
# ✅ 간단함!
F_Wind = [-D, 0, -L]  # 항상 이 형태!
F_Body = DCM_WB @ F_Wind  # 받음각으로 변환
```

---

#### 3.2.3 좌표계 간 변환: 방향 코사인 행렬 (DCM)

**핵심 문제**: 운동방정식은 **하나의 좌표계**에서만 성립한다!
```python
# 뉴턴 제2법칙 (Body 좌표계 선택)
m × a_Body = F_total_Body

# 하지만 힘들이 다른 좌표계로 주어짐:
F_gravity_NED = [0, 0, m*g]
F_thrust_Body = [T, 0, 0]
F_aero_Wind = [-D, 0, -L]

# → 모두 Body로 변환 필요!
```

**방향 코사인 행렬 (Direction Cosine Matrix, DCM)**:

두 좌표계 간 **회전 관계**를 나타내는 3×3 행렬.

**예시: NED → Body 변환**
```
       NED                   Body
        N                     F
        ↑                    ↗
        |         DCM       /
    ----●---- E  =====>  ●---- R
        |              ↙
        ↓ D           D
```

**쿼터니언 기반 DCM (Zipfel 2007, Eq. 4.80)**:

본 프로젝트는 자세를 쿼터니언 q = [q₀, q₁, q₂, q₃]로 표현하고, 이로부터 DCM을 계산한다:
```python
def quaternion_to_dcm(q0, q1, q2, q3):
    """
    쿼터니언 → DCM 변환
    
    Returns: C_BN (Body ← NED 변환 행렬)
    
    Reference: Zipfel (2007), Eq. 4.80
    """
    C_BN = np.array([
        [q0**2 + q1**2 - q2**2 - q3**2,  2*(q1*q2 - q0*q3),            2*(q1*q3 + q0*q2)           ],
        [2*(q1*q2 + q0*q3),              q0**2 - q1**2 + q2**2 - q3**2, 2*(q2*q3 - q0*q1)           ],
        [2*(q1*q3 - q0*q2),              2*(q2*q3 + q0*q1),            q0**2 - q1**2 - q2**2 + q3**2]
    ])
    
    return C_BN
```

**행렬 표기법**:
```
C_BN = DCM from NED to Body
     = "Body ← NED" 변환

사용법:
v_Body = C_BN @ v_NED
```

**역변환 (Body → NED)**:
```python
# DCM은 직교행렬이므로
C_NB = C_BN.T  # 전치행렬 = 역행렬

v_NED = C_NB @ v_Body
```

---

#### 3.2.4 실제 구현 예시: 모든 힘을 Body로 통합
```python
def calculate_forces_body(self, state, t):
    """
    6DOF 운동방정식: 모든 힘을 Body 좌표계로 통합
    
    Reference: Stevens & Lewis (2003), Eq. 1.7-16
    """
    # 상태 추출
    q0, q1, q2, q3 = state[6:10]  # 쿼터니언
    u, v, w = state[3:6]          # Body 속도
    
    # === 1. DCM 계산 ===
    C_BN = quaternion_to_dcm(q0, q1, q2, q3)  # Body ← NED
    
    # === 2. 중력 (NED → Body 변환) ===
    g_NED = np.array([0, 0, self.g])
    g_Body = C_BN @ g_NED
    F_gravity_Body = self.mass * g_Body
    
    # === 3. 추력 (이미 Body) ===
    thrust = self.get_thrust(t)
    F_thrust_Body = np.array([thrust, 0, 0])
    
    # === 4. 공력 (Wind → Body 변환) ===
    V_rel = np.sqrt(u**2 + v**2 + w**2)
    alpha = np.arctan2(w, u)  # 받음각
    beta = np.arcsin(v / V_rel)  # 옆미끄럼각
    
    # Wind 좌표계에서 공력
    D = 0.5 * rho * V_rel**2 * S * self.C_D(mach, alpha)
    Y = 0.5 * rho * V_rel**2 * S * self.C_Y(beta)
    L = 0.5 * rho * V_rel**2 * S * self.C_L(alpha)
    
    F_aero_Wind = np.array([-D, Y, -L])
    
    # Wind → Body 변환 (받음각, 옆미끄럼각 회전)
    C_BW = self.wind_to_body_dcm(alpha, beta)
    F_aero_Body = C_BW @ F_aero_Wind
    
    # === 5. 합력 (모두 Body 좌표계) ===
    F_total_Body = F_gravity_Body + F_thrust_Body + F_aero_Body
    
    return F_total_Body
```

---

#### 3.2.5 좌표계 선택의 핵심 원리

| 좌표계 | 원점 | 언제 사용? | 대표 물리량 |
|--------|------|----------|-------------|
| **NED (Inertial)** | 발사점 (고정) | 위치, 중력 | g, position, trajectory |
| **Body** | 미사일 CG (이동) | 회전, 추력, 관성 | ω, T, I, M_aero |
| **Wind** | 미사일 CG (이동) | 공력 | D, L, α, β |

**Rule of Thumb**:
1. **물리량이 정의된 좌표계**에서 먼저 계산
2. **운동방정식을 풀 좌표계** (보통 Body)로 변환
3. **가시화/분석용 좌표계** (보통 NED)로 최종 변환

---

#### 3.2.6 좌표계 혼란 문제 (섹션 6.1 참조)

**초기 구현 실수**:
```python
# ❌ 틀린 코드 (프로젝트 초기)
F_total = g_NED + thrust_Body + aero_Wind  # 차원 불일치!
```

**디버깅 과정**:
1. 시뮬레이션 결과: 미사일이 옆으로 날아감 (?!)
2. 원인 파악: 중력을 Body로 변환 안함
3. 수정:
```python
# ✅ 올바른 코드
g_Body = C_BN @ g_NED
F_total_Body = m*g_Body + thrust_Body + (C_BW @ aero_Wind)
```

**교훈**: 
> "6DOF에서 가장 흔한 버그는 **좌표계 혼합**이다. 모든 벡터 연산 전에 좌표계를 확인하라!"

---

#### 3.2.7 DCM 검증 방법

**직교성 검증**:
```python
def validate_dcm(C):
    """DCM 타당성 검사"""
    # 1. 직교성: C @ C.T = I
    I_check = C @ C.T
    assert np.allclose(I_check, np.eye(3), atol=1e-10)
    
    # 2. 행렬식: det(C) = 1 (오른손 좌표계)
    det = np.linalg.det(C)
    assert np.abs(det - 1.0) < 1e-10
    
    # 3. 각 행/열의 노름: ||row|| = 1
    for i in range(3):
        assert np.abs(np.linalg.norm(C[i, :]) - 1.0) < 1e-10
```

**시뮬레이션 중 검증**:
```python
# 매 타임스텝마다
C_BN = quaternion_to_dcm(q0, q1, q2, q3)
validate_dcm(C_BN)  # 쿼터니언 정규화 문제 조기 발견
```

---

#### 3.2.8 참조 문헌

- **Stevens, B. L., & Lewis, F. L. (2003).** *Aircraft Control and Simulation* (2nd ed.). Wiley. 
  - Chapter 1.3: Coordinate Systems
  - Chapter 1.4: Euler Angles and DCM
  
- **Zipfel, P. H. (2007).** *Modeling and Simulation of Aerospace Vehicle Dynamics* (2nd ed.). AIAA.
  - Chapter 3.2: Frames and Coordinate Systems
  - Chapter 4.3: Quaternion Kinematics
  
- **Fleeman, E. L. (2012).** *Tactical Missile Design* (2nd ed.). AIAA.
  - Chapter 9: Flight Simulation Coordinate Systems

---

---

## 4. TVC 및 공력 모멘트 구현

#### 4.0 기본 개념 정의 (독자를 위한 용어 설명)

본 프로젝트를 이해하기 위해 필요한 핵심 용어들을 먼저 정의한다.

#### 4.0.1 TVC (Thrust Vector Control)란?

**추력 벡터 제어 (Thrust Vector Control)**는 로켓 엔진의 추력 방향을 바꿔 미사일의 자세를 제어하는 시스템이다. 

**물리적 원리**:
```
F_thrust = 100,000 N (추력)
δ = 10° (편향각)
L_arm = 5 m (CG에서 노즐까지 거리)

→ M = F × sin(δ) × L_arm
  = 100,000 × sin(10°) × 5
  = 86,824 N·m (회전 모멘트)
```

이 모멘트가 미사일을 회전시켜 비행 방향을 바꾼다.

**TVC 구현 방식**:

| 방식 | 설명 | 장점 | 단점 | 예시 |
|------|------|------|------|------|
| **Jet Vane** | 노즐 내부에 흑연 날개 삽입 | 간단, 롤 제어 가능 | I_sp 손실 3% | V-2, SCUD, **KN-23** |
| **Gimbaled Nozzle** | 노즐 전체를 회전 | 효율적, 손실 적음 | 무겁고 비쌈 | THAAD, Standard |
| **Hot Gas Injection** | 노즐에 가스 분사 | 빠른 응답 | 고온 밸브 필요 | - |

**본 프로젝트 선택: Jet Vane 방식**

KN-23은 우크라이나 잔해 분석 결과 **흑연 제트 베인(Graphite Jet Vane)** 사용이 확인되었다 (Fleeman, 2012; 프로젝트 참조 문헌). SCUD-B와 Nodong도 동일 방식 사용.

**장점**:
- 구조 단순 → 제작 용이
- 차동 편향으로 롤 제어 가능
- 대기권 내 비행에 충분한 제어력

**단점**:
- 추력 손실 ~3% (베인이 배기류에 항상 노출)
- 베인 침식으로 연소 종료 시 제어력 감소

#### 4.0.2 공력(Aerodynamics) 기본 개념

**공력(Aerodynamic Force/Moment)**이란 공기의 흐름이 미사일에 가하는 힘과 모멘트를 의미한다.

**핵심 물리량**:

1. **동압 (Dynamic Pressure)**:
```
q = 0.5 × ρ × V²

ρ: 공기 밀도 [kg/m³]
V: 속도 [m/s]
```

예시:
- 고도 0km, 속도 300 m/s → q = 0.5 × 1.225 × 300² = 55,125 Pa
- 고도 50km, 속도 1500 m/s → q = 0.5 × 0.001 × 1500² = 1,125 Pa

→ **고도가 높아지면 밀도가 낮아져 동압 감소 → 공력 약화**

2. **받음각 (Angle of Attack, α)**:
```
α = arctan(w / u)

u: Body-x 방향 속도 (전진 방향)
w: Body-z 방향 속도 (수직 방향)
```

미사일의 진행 방향과 기수(nose)가 향하는 방향의 차이.

3. **옆미끄럼각 (Sideslip Angle, β)**:
```
β = arcsin(v / V_total)

v: Body-y 방향 속도 (측면 방향)
```

#### 4.0.3 공력 모멘트 계수

공력 모멘트는 다음 형태로 계산된다:
```
M_aero = q × S × c × C_m

q: 동압
S: 기준 면적 (미사일 단면적)
c: 기준 길이 (직경 또는 전체 길이)
C_m: 무차원 모멘트 계수
```

**모멘트 계수 구성**:
```
C_m = C_m_0 + C_m_α × α + C_m_q × (q·c/2V) + C_m_δ × δ

C_m_0: 트림 모멘트 (보통 0)
C_m_α: 받음각 효과 (정적 안정성)
C_m_q: 피치율 효과 (동적 댐핑)
C_m_δ: 제어면 효과
```

**왜 C_m_α는 음수인가?**
```
        CG
         ↓
 ----●----▶ (미사일)
     |
     ↑ α > 0 (기수 위로)
```

받음각 α > 0일 때:
- 앞쪽(노즈)에서 양력 ↑ (위로)
- 뒤쪽(꼬리)에서 양력 ↑↑ (더 위로, 면적 큼)
→ 뒤쪽이 더 들려서 **기수가 아래로 회전** (복원 모멘트)
→ **C_m_α < 0** (정적 안정, Static Stability)

**왜 C_m_q는 음수인가?**
```
미사일이 위로 회전 중 (q > 0):
 ↑
 ●---> (회전 방향)
 ↓
```

피치 각속도 q > 0일 때:
- 앞쪽은 상향 기류 발생 → 양력 증가
- 뒤쪽은 하향 기류 발생 → 양력 감소
→ 회전을 **방해**하는 모멘트 발생
→ **C_m_q < 0** (공력 댐핑, Aerodynamic Damping)

**공력 댐핑의 의미**:

마치 댐퍼(shock absorber)처럼, 미사일의 흔들림(진동)을 자동으로 줄여주는 효과. C_m_q가 클수록 진동이 빨리 사라진다.

#### 4.0.4 표준 대기 모델 (Standard Atmosphere)

공력을 계산하려면 고도별 공기 밀도를 알아야 한다. 본 프로젝트는 **1976 U.S. Standard Atmosphere** 모델을 사용한다.

**대류권 (0-11 km)**:
```python
T(h) = T_0 - L × h
     = 288.15 - 0.0065 × h  [K]

ρ(h) = ρ_0 × (T(h) / T_0)^((g / (R × L)) - 1)
     = 1.225 × (T(h) / 288.15)^(5.2561)  [kg/m³]

T_0 = 288.15 K (해수면 온도)
L = 0.0065 K/m (온도 감률)
ρ_0 = 1.225 kg/m³ (해수면 밀도)
g = 9.80665 m/s²
R = 287.05 J/(kg·K)
```

**성층권 (11-47 km)**:
```python
T(h) = 216.65 K (일정)
ρ(h) = ρ_11km × exp(-g × (h - 11000) / (R × T))
     = 0.3639 × exp(-0.0001577 × (h - 11000))  [kg/m³]
```

**변인 통제의 중요성**:

실제 대기는 날씨, 계절, 위도에 따라 변하지만, 시뮬레이션은 **표준 모델**을 사용해 변수를 통제한다. 이렇게 해야 미사일 자체의 특성만 비교 가능하다.

**레퍼런스**: Stevens & Lewis (2003), *Aircraft Control and Simulation*, Appendix A

---

### 4.1 TVC (Thrust Vector Control) 시스템

#### 4.1.1 Jet Vane 기반 TVC 구현

본 프로젝트는 KN-23의 실제 하드웨어인 **흑연 제트 베인**을 모델링한다.

**물리적 구조**:
```
        배기 노즐
    ╔════════════╗
    ║  ↑↑↑↑↑↑↑  ║  ← 추력 방향
    ║  ↑↑●↑↑↑↑  ║  ● = Jet Vane (흑연)
    ║  ↑↑/↑↑↑↑  ║  베인 각도 δ
    ╚════════════╝
```

베인을 각도 δ만큼 기울이면:
- 배기류가 베인에 충돌
- 반작용으로 추력 방향 편향
- 모멘트 발생: M = T × sin(δ) × L_arm

**액추에이터 모델링 (1차 지연 + Rate Limit)**:

실제 서보모터는 즉시 명령각에 도달하지 못한다. 다음 두 가지 제약이 있다:

1. **시정수 (Time Constant, τ)**: 명령과 실제 각도의 시간 지연
2. **각속도 제한 (Rate Limit)**: 최대 회전 속도
```python
class TVCActuator:
    """
    Jet Vane 액추에이터 동역학 모델
    
    Parameters (Fleeman 2012, Chapter 8):
        tau: 시정수 [s] - 0.05s (50ms 응답)
        max_deflection: 최대 편향각 [deg] - ±10°
        rate_limit: 최대 각속도 [deg/s] - 75 deg/s
    """
    def __init__(self, tau=0.05, max_deflection=10.0, rate_limit=75.0):
        self.tau = tau              # 1차 지연 시정수
        self.max_deflection = max_deflection  
        self.rate_limit = rate_limit          
        self.delta = 0.0            # 현재 편향각
        
    def update(self, delta_cmd, dt):
        """
        Args:
            delta_cmd: 명령 편향각 [deg]
            dt: 시간 간격 [s]
        Returns:
            실제 편향각 [deg]
        """
        # 1차 지연 응답 (exponential lag)
        delta_dot = (delta_cmd - self.delta) / self.tau
        
        # Rate limiting (각속도 제한)
        delta_dot = np.clip(delta_dot, -self.rate_limit, self.rate_limit)
        
        # 오일러 적분
        self.delta += delta_dot * dt
        
        # Saturation (물리적 한계)
        self.delta = np.clip(self.delta, -self.max_deflection, self.max_deflection)
        
        return self.delta
```

**왜 이런 모델이 필요한가?**

만약 액추에이터가 이상적(ideal)이라면:
```
t=0.00s: 명령 δ_cmd = 10° → 즉시 δ = 10°
```

하지만 실제는:
```
t=0.00s: δ_cmd = 10° → δ = 0° (아직 안 움직임)
t=0.05s: δ_cmd = 10° → δ = 6.3° (63% 도달, 1τ)
t=0.10s: δ_cmd = 10° → δ = 8.6° (86% 도달, 2τ)
t=0.15s: δ_cmd = 10° → δ = 9.5° (95% 도달, 3τ)
```

이런 지연이 **제어 루프 안정성**에 큰 영향을 미친다!

#### 4.1.2 TVC 모멘트 계산

**Body 좌표계에서의 모멘트**:
```python
def tvc_moment(thrust, delta_pitch, delta_yaw, L_arm):
    """
    TVC에 의한 모멘트 계산
    
    Args:
        thrust: 현재 추력 [N]
        delta_pitch: 피치 편향각 [rad]
        delta_yaw: 요 편향각 [rad]
        L_arm: CG에서 노즐 목까지 거리 [m]
        
    Returns:
        M_tvc: Pitching moment [N·m]
        N_tvc: Yawing moment [N·m]
        
    Reference: Zipfel (2007), Eq. 10.83
    """
    # 작은 각도 근사: sin(δ) ≈ δ (δ < 15°일 때 오차 <3%)
    M_tvc = -thrust * delta_pitch * L_arm  # Pitch moment
    N_tvc = -thrust * delta_yaw * L_arm    # Yaw moment
    
    # 음수인 이유: 
    # δ_pitch > 0 (노즐 위로) → 추력이 아래로 → 기수 아래로 회전 (M < 0)
    
    return M_tvc, N_tvc
```

**추력 손실 (Jet Vane Drag)**:

베인이 배기류에 노출되므로 추력 손실 발생:
```python
def thrust_efficiency(delta):
    """
    Jet Vane에 의한 추력 손실
    
    Reference: Fleeman (2012), Table 8-2
    """
    # 편향각 0°: 100% 효율
    # 편향각 10°: 97% 효율 (3% 손실)
    eta = 1.0 - 0.003 * (delta / 10.0)**2
    return eta

T_effective = T_nominal * thrust_efficiency(delta)
```

---

### 4.2 공력 모멘트 (Aerodynamic Moment)

#### 4.2.1 모멘트 계수 정의

공력 모멘트는 다음 **안정성 도함수 (Stability Derivatives)**로 구성된다:

| 계수 | 물리적 의미 | 전형적 값 | 출처 |
|------|-----------|-----------|------|
| **C_m_α** | 받음각 복원력 (정적 안정성) | -3.0 ~ -8.0 /rad | Stevens & Lewis (2003) |
| **C_m_q** | 피치율 댐핑 (동적 안정성) | -10 ~ -50 /rad | Fleeman (2012) |
| **C_n_β** | 옆미끄럼 복원력 | 1.5 ~ 4.0 /rad | Zipfel (2007) |
| **C_n_r** | 요율 댐핑 | -5 ~ -20 /rad | Stevens & Lewis (2003) |
| **C_l_β** | 2면각 효과 (롤 안정성) | -0.5 ~ -2.0 /rad | Fleeman (2012) |
| **C_l_p** | 롤 댐핑 | -3 ~ -10 /rad | Zipfel (2007) |

**본 프로젝트 사용값 (SCUD-B 기준)**:
```python
# config.py에서 설정
SCUD_B_aero = {
    'Cm_alpha': -5.2,  # /rad
    'Cm_q': -25.0,     # /rad  
    'Cn_beta': 2.8,    # /rad
    'Cn_r': -12.0,     # /rad
    'Cl_beta': -1.2,   # /rad
    'Cl_p': -5.5,      # /rad
}
```

**값의 출처 및 추정 방법**:

1. **직접 문헌 참조**: Stevens & Lewis (2003), Table 2.5 (유사 형상)
2. **Missile DATCOM 추정**: 형상 기반 empirical formula
3. **CFD 시뮬레이션 보정**: (시간 부족으로 미실시)

**불확실성 인정**:

이 계수들은 ±30% 불확실성을 가진다. 하지만:
- 상대적 경향성은 보존 (SCUD vs Nodong vs KN-23)
- FFT 검증을 통해 물리적 타당성 확인
- 최종 분류는 레이더 관측 시그니처 사용 (이 계수들과 무관)

#### 4.2.2 안정성 도함수 기반 모멘트 계산
```python
def calculate_aero_moment(self, alpha, beta, p, q, r, V, rho, S, c, b):
    """
    공력 모멘트 계산
    
    Args:
        alpha, beta: 받음각, 옆미끄럼각 [rad]
        p, q, r: Body축 각속도 [rad/s]
        V: 대기속도 [m/s]
        rho: 공기 밀도 [kg/m³]
        S: 기준 면적 [m²]
        c: 기준 길이 (직경) [m]
        b: 날개폭 (롤/요 기준 길이) [m]
        
    Returns:
        L_aero: Rolling moment [N·m]
        M_aero: Pitching moment [N·m]
        N_aero: Yawing moment [N·m]
        
    Reference: Stevens & Lewis (2003), Eq. 2.6-14
    """
    q_bar = 0.5 * rho * V**2  # 동압 [Pa]
    
    # 무차원 각속도 (normalized angular rates)
    p_hat = p * b / (2 * V)  # 롤율
    q_hat = q * c / (2 * V)  # 피치율  
    r_hat = r * b / (2 * V)  # 요율
    
    # Pitching moment coefficient
    Cm = (self.Cm_0 +                    # Trim (보통 0)
          self.Cm_alpha * alpha +         # 정적 안정성
          self.Cm_q * q_hat +             # 동적 댐핑
          self.Cm_delta_e * delta_elev)   # 엘리베이터 효과
    
    M_aero = q_bar * S * c * Cm
    
    # Yawing moment coefficient
    Cn = (self.Cn_0 +
          self.Cn_beta * beta +           # 방향 안정성
          self.Cn_r * r_hat +             # 요 댐핑
          self.Cn_delta_r * delta_rud)    # 러더 효과
    
    N_aero = q_bar * S * b * Cn
    
    # Rolling moment coefficient
    Cl = (self.Cl_beta * beta +           # 2면각 효과
          self.Cl_p * p_hat +             # 롤 댐핑
          self.Cl_delta_a * delta_ail)    # 에일러론 효과
    
    L_aero = q_bar * S * b * Cl
    
    return L_aero, M_aero, N_aero
```

**왜 무차원화 하는가? (p_hat, q_hat, r_hat)**
```
p_hat = p × b / (2V)

p: 각속도 [rad/s] - 프레임 의존적
V: 속도 [m/s] - 비행 조건 의존적
b: 길이 [m] - 미사일 크기

→ p_hat: 무차원 - 일반화된 값!
```

이렇게 하면 다른 크기, 다른 속도의 미사일들을 **같은 기준**으로 비교 가능.

**공력 댐핑의 효과 검증**:
```python
# 시뮬레이션 검증 (섹션 8.3 참조)
# Cm_q = -25 /rad 일 때:
# - 진동 주파수: 0.8 Hz
# - 감쇠비: ζ = 0.45 (적절한 댐핑)

# Cm_q = -50 /rad (과댐핑)일 때:
# - 진동 주파수: 1.2 Hz
# - 감쇠비: ζ = 0.75 (진동 거의 없음)

# Cm_q = -10 /rad (부족댐핑)일 때:
# - 진동 주파수: 0.5 Hz
# - 감쇠비: ζ = 0.20 (진동 오래 지속)
```

#### 4.2.3 고도에 따른 공력 변화

**밀도 감소 효과**:
```python
# 고도 0 km:
rho = 1.225 kg/m³
q_bar (V=500 m/s) = 153,125 Pa
M_aero = 153,125 × 0.6 × 1.0 × (-5.2) × 0.1 = -47,769 N·m

# 고도 50 km:
rho = 0.001 kg/m³
q_bar (V=1500 m/s) = 1,125 Pa
M_aero = 1,125 × 0.6 × 1.0 × (-5.2) × 0.1 = -351 N·m

→ 공력 모멘트가 136배 감소!
```

**대기권 탈출 조건**:
```python
# 고도 100 km 이상:
# rho → 0 → 공력 모멘트 ≈ 0
# TVC만으로 제어 불가 (추진제 소진)
# → Reaction Control System (RCS) 필요
```

본 프로젝트는 대기권 내 비행만 다루므로 RCS는 미구현.

---

### 4.3 제어 루프 통합

#### 4.3.1 자세 제어기 (PD Controller)

초기에는 PID 제어기를 시도했으나 에너지 손실 문제로 **PD 제어기**로 단순화:
```python
def attitude_controller(theta_cmd, theta, q, Kp=2.0, Kd=0.5):
    """
    피치 자세 제어기 (PD Control)
    
    Args:
        theta_cmd: 목표 피치각 [rad]
        theta: 현재 피치각 [rad]
        q: 피치 각속도 [rad/s]
        Kp: 비례 게인
        Kd: 미분 게인
        
    Returns:
        delta_cmd: TVC 명령 편향각 [deg]
        
    Design Notes:
        - 적분항 제거 (섹션 6.1 참조)
        - Kp ↑ → 빠른 응답, 과도한 진동
        - Kd ↑ → 댐핑 증가, 느린 응답
    """
    # 비례 제어: 각도 오차
    error = theta_cmd - theta
    
    # 미분 제어: 각속도 피드백 (댐핑)
    delta_cmd = Kp * error - Kd * q
    
    # TVC 물리적 한계
    delta_cmd = np.clip(delta_cmd, -10, 10)  # ±10°
    
    return delta_cmd
```

**게인 튜닝 과정** (섹션 6.6 참조):
```
시도 1: Kp=5.0, Kd=0.1
→ 결과: 과도한 진동, 발산

시도 2: Kp=1.0, Kd=1.0
→ 결과: 느린 응답, 목표 미달성

시도 3: Kp=2.0, Kd=0.5
→ 결과: 적절한 응답 ✓
```

**Ziegler-Nichols 방법**은 적용 불가 (연소 시간 제한).

#### 4.3.2 TVC + 공력 모멘트 통합

**최종 회전 방정식**:
```python
def rotational_dynamics(self, state, t):
    """
    오일러 회전 방정식 (Euler's Equations)
    
    Reference: Stevens & Lewis (2003), Eq. 1.7-2
    """
    p, q, r = state[7:10]  # 각속도
    
    # 관성 모멘트 (시간 변화, 섹션 3.1.2 참조)
    Ixx = self.Ixx(t)
    Iyy = self.Iyy(t)
    Izz = self.Izz(t)
    
    # TVC 모멘트
    delta_pitch = self.tvc_actuator_pitch.delta
    delta_yaw = self.tvc_actuator_yaw.delta
    M_tvc, N_tvc = self.tvc_moment(thrust, delta_pitch, delta_yaw, L_arm)
    L_tvc = 0  # Jet Vane은 롤 제어 미사용 (본 프로젝트 단순화)
    
    # 공력 모멘트
    L_aero, M_aero, N_aero = self.calculate_aero_moment(...)
    
    # 자이로 모멘트 (회전 중 관성축 변화)
    L_gyro = (Izz - Iyy) * q * r
    M_gyro = (Ixx - Izz) * r * p
    N_gyro = (Iyy - Ixx) * p * q
    
    # 오일러 방정식
    p_dot = (L_aero + L_tvc + L_gyro) / Ixx
    q_dot = (M_aero + M_tvc + M_gyro) / Iyy
    r_dot = (N_aero + N_tvc + N_gyro) / Izz
    
    return [p_dot, q_dot, r_dot]
```

**모멘트 우선순위**:

| 비행 단계 | TVC | 공력 | 자이로 |
|----------|-----|------|--------|
| 발사 직후 (0-5s) | ★★★ 주도적 | ☆ 약함 (저속) | ☆ 무시 |
| 상승 중 (5-40s) | ★★ 강함 | ★★ 증가 | ★ 미약 |
| 연소 종료 (40s+) | ✗ 없음 | ★★★ 유일 | ★ 존재 |

**검증 결과**:
```
SCUD-B (45° 발사):
- TVC 모멘트: 최대 15,000 N·m (t=20s)
- 공력 모멘트: 최대 8,000 N·m (t=35s)
- 자이로 모멘트: 최대 500 N·m (고속 회전 시)

→ TVC가 공력보다 약 2배 강함 (추진 단계)
```

---

## 5. KN-23 저압궤도 (Depressed Trajectory) 구현

### 5.1 저압궤도의 물리적 특성

KN-23은 기존 탄도미사일과 달리 **최대 고도를 낮추고 비행 시간을 단축**하는 저압궤도를 사용한다:

| 특성 | 일반 탄도궤도 | 저압궤도 (KN-23) |
|------|---------------|-------------------|
| 최대 고도 | ~150 km | ~50 km |
| 비행 시간 | ~500 s | ~300 s |
| 발사각 | 45-60° | 20-30° |
| 종말 속도 | ~2 km/s | ~3 km/s |

### 5.2 구현상의 도전과 해결

#### 5.2.1 문제: 과도한 공력 가열

저고도 비행으로 인해 대기 밀도가 높아 공력 저항과 가열이 증가:

```python
# 해결: 밀도 변화를 고려한 동적 비행 경로 최적화
def optimize_trajectory(self, target_range):
    # 밀도가 낮은 고도대를 찾아 비행
    optimal_alt = self.find_optimal_cruise_altitude(target_range)
    # Pull-up 기동 타이밍 최적화
    pullup_time = self.calculate_pullup_timing(optimal_alt, target_range)
    return optimal_alt, pullup_time
```

#### 5.2.2 문제: Pull-up 기동의 안정성

급격한 자세 변환 시 각속도 진동 발생:

```python
# 해결: 부드러운 경로 전환 (S-curve 프로파일)
def smooth_pullup(self, t, t_start, duration):
    tau = (t - t_start) / duration
    if tau < 0: return 0
    if tau > 1: return 1
    # S-curve (5차 다항식)
    return 10*tau**3 - 15*tau**4 + 6*tau**5
```

### 5.3 검증 결과

시뮬레이션 결과 KN-23의 주요 특성이 재현되었다:

- **사거리:** 450 km (목표: 450 km)
- **최대 고도:** 48.7 km (목표: ~50 km)
- **비행 시간:** 287 s
- **종말 속도:** 2.89 km/s

---

## 6. 어려웠던 점 및 해결 방법

### 6.1 좌표계 혼동 문제

#### 문제 상황
NED, ENU, Body 좌표계 간의 변환에서 지속적으로 부호 오류 발생.

#### 해결 방법

```python
# 명확한 변환 함수 정의
def ned_to_body(vec_ned, dcm_bn):
    """NED 좌표계 벡터를 Body 좌표계로 변환"""
    return dcm_bn @ vec_ned

def body_to_ned(vec_body, dcm_bn):
    """Body 좌표계 벡터를 NED 좌표계로 변환"""
    return dcm_bn.T @ vec_body  # DCM의 전치 = 역행렬

# 모든 변환에 일관된 명명 규칙 적용:
# dcm_AB: A에서 B로의 변환 행렬
```

### 6.2 수치 불안정성

#### 문제 상황
RK4 적분 시 쿼터니언 norm이 발산하는 현상.

#### 해결 방법

```python
# 매 스텝마다 쿼터니언 정규화
def normalize_quaternion(q):
    norm = np.sqrt(q[0]**2 + q[1]**2 + q[2]**2 + q[3]**2)
    if norm < 1e-10:
        return np.array([1, 0, 0, 0])  # 안전한 기본값
    return q / norm

# RK4 후 정규화 적용
q_new = rk4_step(q, dq_dt, dt)
q_new = normalize_quaternion(q_new)
```

### 6.3 공력계수 튜닝

#### 문제 상황
문헌값 그대로 적용 시 시스템이 과도하게 안정하거나 불안정.

#### 해결 방법: 체계적 튜닝 프로세스

1. **1단계:** Cm_alpha만 활성화하여 정적 안정성 확인
2. **2단계:** Cm_q (댐핑) 추가하여 진동 감쇠 확인
3. **3단계:** 교차 커플링 항목 (Cn_beta 등) 점진적 추가

```python
# 튜닝 로그 예시
# Cm_alpha = -5.0: 너무 안정, 응답 느림
# Cm_alpha = -2.0: 적절한 응답
# Cm_q = -30: 과도한 댐핑
# Cm_q = -15: 적절한 댐핑 (0.7 damping ratio 목표)
```

### 6.4 89.5° 피치각 문제 (Gimbal Lock) - 무한 적분과 오버플로의 원인

#### 6.4.1 문제 상황: 수치 적분이 멈추지 않음

초기 6DOF 구현에서 오일러각 기반 운동 방정식을 사용했을 때, **발사 초기 피치각 θ=89.5°로 설정하면 시뮬레이션이 폭주**하는 현상이 반복적으로 발생했다:

**관찰된 증상:**
1. **무한 적분 루프**: `scipy.integrate.solve_ivp`가 t=10초 근처에서 수천 번 반복 계산 후 종료되지 않음
2. **각속도 폭주**: 피치율 q가 146°/s까지 폭증 (정상: <5°/s)
3. **자세 발산**: theta가 185° → 321° → 무한대로 발산
4. **수치 오버플로**: `RuntimeWarning: overflow encountered in double_scalars` 
5. **조기 추락**: 9.7초 만에 비행 종료 (정상: 300초)

**실제 디버깅 로그:**
```
t=10.0s: theta=185.7° (목표: 90°) ← 이미 2배로 폭주
q=146.7°/s ← 각속도 30배 증가
dψ/dt 계산 중 오버플로 발생
t=10.1s: solver가 dt=1e-9초로 축소 시도
t=10.1s: solver가 dt=1e-12초로 재축소
... (무한 반복, CPU 100% 사용)
```

#### 6.4.2 근본 원인: Gimbal Lock 특이점

**수학적 원인 - 오일러각 운동 방정식의 특이점 (Stevens & Lewis, 2003, Eq. 1.8-8):**

오일러각(φ, θ, ψ)과 각속도(p, q, r)의 관계식:

```
[dφ/dt ]   [1  sin(φ)tan(θ)  cos(φ)tan(θ) ] [p]
[dθ/dt ] = [0  cos(φ)        -sin(φ)      ] [q]
[dψ/dt ]   [0  sin(φ)/cos(θ) cos(φ)/cos(θ)] [r]
```

**핵심 문제: θ → 90°일 때 cos(θ) → 0**

1. **특이점 발생**: dψ/dt의 분모에 cos(θ)가 있어, θ=90°에서 **분모가 0에 근접**
2. **tan(θ) 폭발**: tan(90°) = ∞이므로 dφ/dt도 발산
3. **수치 불안정**: 적분기(solver)가 특이점을 피하려고 시간 간격을 무한히 축소 → **무한 루프**

**왜 89.5°도 문제인가?**

```python
# 89.5°는 90°가 아니지만 수치적으로는 거의 같다:
cos(89.5°) = 0.00873  # 거의 0!
tan(89.5°) = 114.6    # 이미 폭발 수준

# Pitch phase 시작 (t=10초) 시점 계산:
dψ/dt = (q*sin(φ) + r*cos(φ)) / cos(θ)
      = (q*sin(0) + r*cos(0)) / 0.00873
      = r / 0.00873
      = 0.5 rad/s / 0.00873
      = 57.3 rad/s  (= 3,283°/s) ← 현실적으로 불가능한 값!
```

이 계산에서 나온 3,283°/s는 물리적으로 불가능한 값이며, 이것이 연쇄적으로 다른 각도들을 폭주시킨다.

#### 6.4.3 Gimbal Lock의 물리적 의미

**Gimbal Lock이란?**

Gimbal Lock은 3개의 회전축 중 2개가 정렬되어 1개 자유도를 잃는 현상이다:

```
정상 상태 (θ=0°):          Gimbal Lock (θ=90°):
    ↑ y (pitch)                 ↑ y (pitch)
    |                           |
    |                           |
    +---→ x (roll)              +---→ x (roll)
   /                           / ← z축(yaw)이 x축과 
  ↙ z (yaw)                   /   평행하게 정렬!
                             ↙ z (yaw)
                             
yaw, pitch, roll이         yaw와 roll이 같은 평면에서
독립적으로 회전 가능       회전 → 2개를 구별할 수 없음
```

**왜 문제인가?**

θ=90°에서 yaw(ψ)와 roll(φ)이 같은 평면에서 회전하므로:
- ψ를 5° 증가 = φ를 5° 증가와 같은 효과
- 두 각도를 독립적으로 결정할 수 없음
- 수학적으로는 무한개의 해가 존재 (under-determined system)

**수치 적분기 관점에서 왜 무한 루프가 발생하는가?**

```python
# Radau stiff solver는 Jacobian 행렬을 계산:
J = ∂f/∂x
# θ=90° 근처에서:
∂(dψ/dt)/∂ψ = ∂(... / cos(θ))/∂ψ → ∞
```

- Jacobian의 조건수(condition number)가 폭발 → 행렬이 singular에 가까워짐
- Solver가 안정적인 스텝 크기를 찾지 못함
- dt를 10⁻⁹, 10⁻¹², 10⁻¹⁵ 초로 계속 축소 → 무한 반복
- 실제로는 부동소수점 정밀도 한계(~10⁻¹⁶)에 도달해도 해결 불가

#### 6.4.4 해결: 쿼터니언 전환

**쿼터니언 운동 방정식 (Zipfel, 2007, Eq. 4.77):**

```
dq₀/dt = -0.5(p·q₁ + q·q₂ + r·q₃)
dq₁/dt =  0.5(p·q₀ + r·q₂ - q·q₃)
dq₂/dt =  0.5(q·q₀ - r·q₁ + p·q₃)
dq₃/dt =  0.5(r·q₀ + q·q₁ - p·q₂)
```

**핵심 장점:**

| 특성 | 오일러각 | 쿼터니언 |
|------|----------|----------|
| 특이점 | θ=±90°에서 발생 | 특이점 없음 ✓ |
| 방정식 형태 | 비선형 (tan, sin/cos 포함) | 선형 (곱셈만) ✓ |
| 수치 안정성 | cos(θ)→0에서 불안정 | 모든 각도에서 안정 ✓ |
| 정규화 필요 | 불필요 | norm=1 유지 필요 (간단) |

**왜 쿼터니언은 특이점이 없는가?**

- 4차원 단위 구면(S³)에서 회전을 표현
- 모든 방향이 동등하게 표현됨 (no preferred axis)
- 3D 회전의 이중 커버(double cover) → 연속성 보장

**구현:**

```python
def euler_to_quaternion(psi, theta, phi):
    """
    89.5°도 문제없이 처리!
    특이점 없음, 모든 각도에서 안정적
    """
    cy, sy = np.cos(psi/2), np.sin(psi/2)
    cp, sp = np.cos(theta/2), np.sin(theta/2)
    cr, sr = np.cos(phi/2), np.sin(phi/2)
    
    q0 = cy*cp*cr + sy*sp*sr
    q1 = cy*cp*sr - sy*sp*cr
    q2 = cy*sp*cr + sy*cp*sr
    q3 = sy*cp*cr - cy*sp*sr
    
    return np.array([q0, q1, q2, q3])

# theta=89.5° 초기화 예시:
q_init = euler_to_quaternion(psi=0, theta=89.5*DEG_TO_RAD, phi=0)
# q_init = [0.0076, 0, 0.9999, 0]  ← 유효한 단위 쿼터니언
# norm = 1.0000 (완벽하게 정규화됨)
```

#### 6.4.5 해결 후 결과 비교

쿼터니언 전환 후 시뮬레이션 성능이 극적으로 개선되었다:

| 항목 | 오일러각 (실패) | 쿼터니언 (성공) | 개선율 |
|------|----------------|----------------|--------|
| 비행 시간 | 9.7s (조기 추락) | 287s (정상) | 29.6배 |
| 최대 각속도 q | 146°/s (폭주) | 4.2°/s (안정) | 34.8배 감소 |
| 적분 스텝 수 | >10,000 (무한) | 518 (정상) | 19.3배 감소 |
| 수치 오류 | 오버플로 발생 | 없음 | ✓ |
| theta 범위 | 185° → ∞ (발산) | -90° ~ +90° (정상) | ✓ |
| CPU 시간 | >300s (타임아웃) | 1.2s | 250배 빠름 |

**정확도 검증:**

```python
# 쿼터니언 norm 체크 (적분 오차 누적 확인)
for t in simulation_time:
    norm_error = abs(np.linalg.norm(q) - 1.0)
    assert norm_error < 1e-10  # 모두 통과!

# 에너지 보존 체크
E_kinetic = 0.5 * I * omega**2
E_potential = m * g * h
E_total_error = abs((E_final - E_initial) / E_initial)
assert E_total_error < 0.01  # 1% 미만 (정상)
```

#### 6.4.6 핵심 교훈 및 시사점

**"89.5°는 90°가 아니지만, 수치 계산에서는 거의 같다."**

**Gimbal Lock 회피 전략은 실패:**
- cos(89.5°) = 0.00873 ← "거의 0"
- 0.5° 차이는 수치 안정성에 전혀 도움 안 됨
- 특이점으로부터 "충분히 먼" 각도도 없음 (θ>85°면 모두 불안정)

**근본 해결책:**
- 표현법 자체를 바꿔야 함 (오일러각 → 쿼터니언)
- 특이점을 "피하는" 것이 아니라 특이점이 없는 방법 사용
- 이것이 NASA, SpaceX 등 실제 우주/항공 분야에서 쿼터니언을 쓰는 이유

**6DOF 시뮬레이션의 교훈:**
- 단순히 "공식을 코드로 옮기는" 것만으로는 부족
- 수치 안정성이 물리적 정확성만큼 중요
- 실제 공학 문제에서는 "이론적으로 맞는" 방법보다 수치적으로 안정한 방법이 우선

### 6.5 시뮬레이션과 관측의 괴리

#### 문제 상황
시뮬레이션에서 계산한 각속도를 실제 레이더가 관측할 수 있는지 불명확.

#### 해결 방법
관측 가능한 물리량으로 변환:

```python
# 레이더 관측 가능 각도로 변환
def simulate_radar_observation(state, radar_pos):
    """
    시뮬레이션 상태에서 레이더가 관측할 수 있는 값 추출
    """
    # 위치, 속도 (직접 관측 가능)
    range_vec = state['pos'] - radar_pos
    range_rate = np.dot(state['vel'], range_vec) / np.linalg.norm(range_vec)
    
    # 각속도는 도플러 변조나 표적 크기 변화로 간접 추정
    # 이 부분이 실제 운용에서의 핵심 도전
    return {
        'range': np.linalg.norm(range_vec),
        'range_rate': range_rate,
        'azimuth': np.arctan2(range_vec[1], range_vec[0]),
        'elevation': np.arcsin(-range_vec[2] / np.linalg.norm(range_vec))
    }
```

---

## 7. 시각화 및 시스템 정합성 검토 (정연우)

### 7.1 12채널 실시간 시각화 대시보드 구축

물리 엔진에서 산출되는 14개 상태 변수와 유도 물리량을 실시간으로 모니터링하기 위해 3x4 그리드 방식의 종합 분석 대시보드를 구축하였다.


| 채널 | 물리량 | 목적 |
|------|--------|------|
| 1-3 | 위치 (x, y, z) | 궤적 추적 |
| 4-6 | 속도 (vx, vy, vz) | 운동 상태 확인 |
| 7-9 | 오일러각 (ψ, θ, φ) | 자세 변화 모니터링 |
| 10-12 | 각속도 (p, q, r) | FFT 분석용 신호 확인 |
| 구분 | 채널(Subplot) | 분석 내용 및 목적 |
| --- | --- | --- |
| **Row 1: 기본 궤적** | 3D Trajectory / Velocity / Altitude / AoA(알파) | 발사-정점-착탄 전 과정 추적 및 속도, 고도, 받음각 프로파일 확인 |
| **Row 2: 자세 제어** | Euler Angles / Angular Rates / Flight Path / Mach | 3축 자세 변화(phi, theta, psi), 각속도(p, q, r), 마하수 검증 |
| **Row 3: 시그니처** | Phase Plane / Ground Track / Range-Alt / Roll-Yaw | 제어 안정성(alpha-q 위상), 수평 궤적, 탄도 형상 및 축 간 결합 분석 |

* **구현 특징:** Matplotlib 기반 고해상도(300 DPI) 출력 및 타임스탬프 기반 자동 저장 시스템 구축.

### 7.2 기술적 난제 해결: 각도 Wrapping 처리

탄도 비행 중 피치각(theta)이 누적되어 범위를 초과할 경우, 그래프에 불연속적인 점프가 발생하는 문제를 해결하기 위해 각도 정규화(Wrapping) 로직을 적용하였다.

```python
def wrap_angle(angle):
    """각도를 -pi ~ pi 범위로 정규화하여 시각화 불연속성 제거"""
    import numpy as np
    while angle > np.pi: 
        angle -= 2 * np.pi
    while angle < -np.pi: 
        angle += 2 * np.pi
    return angle

# 시각화 데이터 생성 시 적용
theta_wrapped = np.array([wrap_angle(th) for th in theta])

```

이를 통해 시각화 단계에서 물리적으로 유효한 범위 내의 각도 표현을 유지하며 데이터 가독성을 확보하였다.

### 7.3 시나리오 통합 및 좌표계 변환

KN-23(2D 저압궤도 전용)과 SCUD-B/Nodong(6DOF) 시뮬레이터의 결과 포맷을 통일하여 단일 시각화 인터페이스에서 처리할 수 있도록 설계하였다.

* **좌표계 변환:** Body Frame 속도(u, v, w)를 바탕으로 총 속도(V), 받음각(alpha), 옆미끄럼각(beta)을 계산한다.
* **대기 모델 통합:** ISA 1976 표준 대기 모델을 시각화 모듈에 내장하여 고도에 따른 음속 변화와 마하수를 실시간으로 계산한다.

### 7.4 NPZ 기반 "더블 체크" 검증 시스템

물리 시뮬레이션 결과와 시각화 데이터 간의 정합성을 보장하기 위해 NPZ 파일 기반의 교차 검증 워크플로우를 구축하였다.

```python
class SystemValidator:
    """NPZ 저장 데이터를 로드하여 물리 법칙 정합성 검증"""
    def __init__(self, npz_filepath):
        import numpy as np
        self.data = np.load(npz_filepath, allow_pickle=True)
        
    def check_consistency(self):
        checks = {
            'quaternion_norm': self._check_q_norm(), # 쿼터니언 크기 1 유지 여부
            'energy_conservation': self._check_energy(), # 탄도 구간 에너지 보존
            'kinematic_match': self._check_kinematics() # 위치 미분과 속도 데이터 일치 여부
        }
        return all(checks.values()), checks

    def _check_q_norm(self):
        import numpy as np
        # 쿼터니언 정규화 오차 검증 (허용 오차 1e-6)
        q_data = np.stack([self.data['q0'], self.data['q1'], 
                          self.data['q2'], self.data['q3']], axis=1)
        norms = np.linalg.norm(q_data, axis=1)
        return np.max(np.abs(norms - 1.0)) < 1e-6

```

이 시스템을 통해 시뮬레이터의 수치적 오류를 시각화 전 단계에서 필터링하며, 저장된 NPZ 파일이 분류 모델(SVM)의 입력값으로 사용되기에 충분한 신뢰도를 갖췄는지 검증한다.

### 7.5 위상 평면(Phase Plane) 분석을 통한 안정성 검토

제어 시스템의 동적 특성을 파악하기 위해 받음각(alpha)과 피치 각속도(q)의 상관관계를 나타내는 위상 평면 분석 기능을 구현하였다.

* **alpha-q Phase Plane:** 제어 루프가 원점으로 수렴하는 나선형 궤적을 그리는지 확인하여 TVC 제어기의 안정성을 매 시뮬레이션마다 검증한다.
* **p-r Coupling:** 롤(Roll)과 요(Yaw)의 위상 분석을 통해 비대칭 기동 시 발생하는 관성 결합 효과를 시각적으로 탐지한다.


---

## 8. 미사일 판별을 위한 Signature 물리량 발견

### 8.1 FFT 분석 기반 접근

각속도 시계열 데이터에서 FFT를 수행하여 주파수 영역 특성을 추출:

```python
def extract_fft_features(angular_velocity, dt):
    """
    각속도 시계열에서 FFT 특성 추출
    """
    N = len(angular_velocity)
    freq = np.fft.fftfreq(N, dt)
    fft_result = np.fft.fft(angular_velocity)
    magnitude = np.abs(fft_result)
    
    # 0.3-1.5 Hz 대역 분석
    band_mask = (freq > 0.3) & (freq < 1.5)
    band_power = np.sum(magnitude[band_mask]**2)
    dominant_freq = freq[band_mask][np.argmax(magnitude[band_mask])]
    
    return {
        'band_power': band_power,
        'dominant_freq': dominant_freq,
        'spectral_entropy': calculate_entropy(magnitude[band_mask])
    }
```

### 8.2 추출된 9개 Signature 특성

| # | 특성명 | 물리적 의미 | 단위 |
|---|--------|-------------|------|
| 1 | natural_freq | 피치 고유진동수 | Hz |
| 2 | damping_ratio | 감쇠비 | - |
| 3 | roll_yaw_coupling | 롤-요 커플링 강도 | - |
| 4 | max_pitch_rate | 최대 피치율 | deg/s |
| 5 | pitch_energy | 피치 진동 에너지 | (deg/s)² |
| 6 | trajectory_curvature | 궤적 곡률 | 1/km |
| 7 | apogee_time_ratio | 정점까지 시간 비율 | - |
| 8 | terminal_dive_angle | 종말 강하각 | deg |
| 9 | velocity_at_apogee | 정점 속도 비율 | - |

### 8.3 미사일별 특성 차이

| 미사일 | 고유진동수 | 감쇠비 | 궤적 곡률 |
|--------|-----------|--------|-----------|
| SCUD-B | 0.45 Hz | 0.65 | 낮음 |
| Nodong | 0.38 Hz | 0.72 | 중간 |
| KN-23 | 0.82 Hz | 0.55 | 높음 (저압궤도) |

### 8.4 (시행착오 정리) FFT 기반 6DOF 물리량의 위치와, 최종 분류 입력의 범위

박윤준·정연우는 6DOF 시뮬레이터를 설계/구현하는 과정에서 각속도(roll/pitch/yaw rate) 기반 FFT 분석을 포함하여 "고유진동수/감쇠비/커플링"과 같은 동특성 물리량을 실험적으로 구현·검증하였다. 이 과정은 **시뮬레이터의 동역학 구현이 타당한지** 확인하는 데 매우 중요했고, 모델 안정화에도 직접 기여했다.

다만 본 프로젝트의 "탄종 분류"는 실제 운용 환경(레이더 관측)에서 확보 가능한 정보로 변인통제해야 하므로, **최종 분류 모델의 입력(feature)은 '레이더 트랙(추적)으로부터 계산 가능한 시그니처'로 한정**하였다. 즉, FFT 기반 동특성 물리량은:
1. 시뮬레이터 검증 및 확장 연구의 기반으로 유지
2. 최종 학습/평가 파이프라인에서는 아래의 **레이더 관측 기반 15개 시그니처**를 사용

---

### 8.5 레이더 관측 기반 15개 시그니처 설계 (김찬진)

#### 8.5.1 설계 원칙: "레이더 관측 가능성"으로 변인 통제

본 프로젝트에서 탄종 분류 입력(feature)은 다음 원칙을 따른다:

| 원칙 | 설명 |
|------|------|
| **관측 가능성(Observability)** | 레이더가 제공/추정 가능한 값(위치·속도·가속도 등 트랙 기반 파생량)만 사용 |
| **강건성(Robustness)** | 노이즈/샘플링 변화에 민감한 원시 파형 대신, 트랙 기반 요약·형상(feature) 중심 |
| **해석 가능성(Interpretability)** | 물리적 의미를 고려한 시그니처 설계 |
| **일반화 가능성(Generalization)** | 다양한 환경/조건에서 적용 가능 |

> **주의:** 본 프로젝트의 시그니처 설계는 "레이더 관측 가능성"을 우선하여 진행되었으며, 추후 다양한 센서/환경에 대한 일반화 가능성을 고려해야 한다.

#### 8.5.2 레이더 관측 기반 15개 시그니처

| No | Signature (Feature) | 단위 | 의미 (레이더 트랙 기반 해석) |
|---:|---------------------|------|------------------------------|
| 1 | max_altitude_km | km | 최대 고도(아포지) |
| 2 | final_range_km | km | 최종 사거리(다운레인지) |
| 3 | impact_angle_deg | deg | 종말 단계 낙하각 (현재 구현: body-frame 기반 근사치) |
| 4 | total_flight_time | s | 총 비행시간 |
| 5 | max_velocity | m/s | 최대 속도 |
| 6 | terminal_velocity | m/s | 종말(Impact 직전) 속도 |
| 7 | max_mach | - | 최대 마하수 (표준대기(ISA) 기반 음속으로 계산) |
| 8 | velocity_loss_ratio | - | (최대→종말) 속도 손실 비율 = (Vmax - Vterm)/Vmax |
| 9 | max_deceleration | m/s² | 최대 감속(드래그/기동에 의한 속도 감소 강도) |
| 10 | ground_track_curvature | - | 지상투영 궤적의 곡률/방향 변화(좌우 기동/선회 성분) |
| 11 | path_efficiency | - | 경로 효율 = (직선거리)/(실제 이동거리) |
| 12 | energy_ratio | - | 특정기계에너지 비율(terminal / max), E = v²/2 + g·h |
| 13 | alpha_std_deg | deg | 받음각(α) 변동성 표준편차 †† |
| 14 | q_max_deg_s | deg/s | 피치율(q) 최대값 †† |
| 15 | alpha_q_correlation | - | α-q 상관계수 (기동 패턴) †† |

> **†† 13~15번 시그니처 현실성 주의:**  
> 이 3개 시그니처는 **레이더가 직접 관측하는 값이 아니라, 레이더 추적(위치·속도 시계열)으로부터 유도/추정 가능한 파생 시그니처**이다.  
> - 시뮬레이터에서는 true α, q를 사용해 계산했지만, 실환경에서는 추적 궤적으로부터 동일 지표를 추정하는 형태로 확장 가능  
> - 실제 레이더 적용 시에는 **비행경로각(γ) 변화율, 곡률, 횡가속도** 등 track 기반 대리변수로 대체하거나, micro-Doppler 등 추가 관측을 가정해야 함

#### 8.5.3 시그니처 선정 근거

| 시그니처 그룹 | 선정 이유 | 문헌 근거 |
|---------------|-----------|-----------|
| **궤적 형상 (1-4)** | 탄도미사일 종류별로 사거리/고도/비행시간이 물리적으로 구분됨 | Fleeman (2012), 미사일 성능 파라미터 |
| **속도/마하 (5-8)** | 추력-질량비, 공력특성에 따라 속도 프로파일이 상이 | Siouris (2004), 유도탄 설계 |
| **감속/기동 (9-12)** | 재진입 시 대기 저항, 기동 능력 반영 | Singh et al. (2014), 레이더 기반 분류 |
| **6DOF 기동성 (13-15)** | 저압궤도/Pull-up 기동 등 고급 기동 패턴 구분 | 본 프로젝트 6DOF 시뮬레이션 결과 |

#### 8.5.4 시그니처 추출 파이프라인 (요약)

```python
# signature_generator.py 핵심 구조
SIGNATURE_FEATURES = [
    'max_altitude_km', 'final_range_km', 'impact_angle_deg', 'total_flight_time',
    'max_velocity', 'terminal_velocity', 'max_mach', 'velocity_loss_ratio',
    'max_deceleration', 'ground_track_curvature', 'path_efficiency', 'energy_ratio',
    'alpha_std_deg', 'q_max_deg_s', 'alpha_q_correlation'
]

def extract_signatures(trajectory_data):
    """레이더 트랙(또는 시뮬레이터 궤적)에서 15개 시그니처 추출"""
    signatures = {}
    # 1) 궤적 형상 특성
    signatures['max_altitude_km'] = np.max(trajectory_data['altitude']) / 1000
    signatures['final_range_km'] = trajectory_data['range'][-1] / 1000
    # ... (생략)
    # 2) 속도/마하 특성
    # 3) 감속/기동 특성  
    # 4) 6DOF 기동성 특성
    return signatures
```

**파이프라인 단계:**
1. 레이더 트랙(또는 시뮬레이터 궤적을 레이더 관측치 형태로 변환)에서 3D 위치 시계열 구성
2. 차분 + 필터링/스무딩으로 속도/가속도 및 필요한 파생량(곡률, 에너지 등) 계산
3. 위 15개 요약 통계/형상 특징을 단일 벡터로 구성
4. 학습 시 표준화/정규화(스케일러 저장) 및 모델(RandomForest) 학습
5. **학습/평가 파이프라인 구분:**
   - **학습:** `train_large.py` (랜덤 stratified split으로 모델 학습)
   - **추가 검증:** `eval_by_angle.py` (발사각 그룹 완전 분리 GroupShuffleSplit 평가로 일반화 확인)

---

## 9. 시그니처 분석 방법 선택 (정연우, 김찬진)

본 프로젝트에서는 시그니처 후보를 크게 두 계열로 검토했다.

### 9.1 후보 A: FFT 기반(동특성) 시그니처

- **장점:** 6DOF 동역학이 안정적으로 구현되었는지 검증 가능, 특정 진동/결합 모드가 있을 때 분리 가능
- **한계:** 실제 레이더 운용에서 각속도/자세율을 직접 고신뢰로 얻기 어렵고, 시간-주파수 기반 특징은 관측각/산란 특성 등에 민감하며 계산 비용도 커질 수 있다
- **결론:** "시뮬레이터 검증/확장 연구"의 축으로 유지

### 9.2 후보 B: 레이더 트랙 기반(관측 가능) 시그니처 — 최종 채택

- 레이더는 추적 과정에서 3D 위치를 제공하고, 필터링을 통해 속도/가속도 등의 파생량을 안정적으로 얻을 수 있다
- 탄종 분류 목표에서는 **관측 가능성(변인 통제)**, **강건성**, **해석 가능성**을 우선하여 트랙 기반 요약·형상 특징(최종 15개 시그니처)을 메인 입력으로 채택했다
- **결론:** 최종 학습/평가 파이프라인은 "레이더 트랙 기반 15개 시그니처"를 사용

### 9.3 분류 모델 선택

여러 분류 알고리즘을 비교 검토하였다:

| 알고리즘 | 장점 | 단점 | 선택 여부 |
|----------|------|------|-----------|
| SVM | 고차원에서 효과적, 작은 데이터셋에 강함 | 대규모 데이터 느림 | 초기 검토 후보 (최종 미채택) |
| **Random Forest** | 해석 용이, 특성 중요도 제공, 과적합 방지 | - | ✓ **최종 선택** |
| Neural Network | 비선형 패턴 학습 | 데이터 많이 필요 | - |
| k-NN | 구현 간단 | 차원의 저주 | - |

### 9.4 RandomForest 구현 (개념 코드)

아래는 분류기 구조를 설명하기 위한 **개념 코드**이며, 실제 파이프라인(`train_large.py`, `eval_by_angle.py`)에서는 GroupShuffleSplit 기반 발사각 그룹 분리 및 n_estimators=300 등 상세 설정을 사용한다.

```python
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import cross_val_score
import joblib

class MissileClassifier:
    def __init__(self):
        self.scaler = StandardScaler()
        self.model = RandomForestClassifier(n_estimators=100, random_state=42)
        
    def train(self, X, y):
        X_scaled = self.scaler.fit_transform(X)
        self.model.fit(X_scaled, y)
        
        # 교차 검증
        scores = cross_val_score(self.model, X_scaled, y, cv=5)
        print(f"Cross-validation accuracy: {scores.mean():.2f} ± {scores.std():.2f}")
        
        # 모델 저장
        joblib.dump(self.model, 'rf_model.pkl')
        joblib.dump(self.scaler, 'scaler.pkl')
        
    def predict(self, X):
        X_scaled = self.scaler.transform(X)
        return self.model.predict(X_scaled)
```

### 9.5 분류 결과

5-fold 교차 검증 결과:

| 클래스 | Precision | Recall | F1-Score |
|--------|-----------|--------|----------|
| SCUD-B | 1.00 | 1.00 | 1.00 |
| Nodong | 1.00 | 1.00 | 1.00 |
| KN-23 | 1.00 | 1.00 | 1.00 |
| **평균** | **1.00** | **1.00** | **1.00** |

**혼동 행렬 분석:**
- 발사각 그룹 분리 평가(`eval_by_angle.py`)에서 완벽 분류 달성
- 현재 데이터셋(1500×15)이 잘 분리되는 상태로, 15개 시그니처가 탄종 간 구분에 효과적임을 확인

---

## 10. 결론 및 향후 과제

### 10.1 프로젝트 성과 요약

1. **6DOF 시뮬레이션 완성:** 쿼터니언 기반 완전한 6자유도 시뮬레이터 구현 (박윤준, 정연우)
2. **세 가지 미사일 모델링:** SCUD-B, Nodong, KN-23의 물리적으로 타당한 궤적 생성
3. **FFT 기반 동특성 분석:** 시뮬레이터 검증용 각속도 FFT 구현 (박윤준, 정연우)
4. **레이더 관측 기반 15개 시그니처 설계:** 변인통제된 최종 분류 입력 (김찬진)
5. **RandomForest 분류기 개발:** 발사각 그룹 분리 평가 100% 정확도의 탄종 분류기 구현 (김찬진)
6. **시각화 도구 구축:** 12채널 실시간 모니터링 시스템 (정연우)

### 10.2 한계점

- **실제 데이터 부재:** 시뮬레이션 데이터로만 학습, 실제 레이더 데이터 검증 필요
- **환경 요인 미반영:** 바람, 대기 불안정성 등 미고려
- **단일 레이더 가정:** 다중 센서 융합 미구현
- **KN-23 궤적 고정:** KN-23은 저압궤도(depressed trajectory)로 제어되는 시나리오로 구현되어, 입력 발사각 변화가 SCUD-B/Nodong처럼 직접 반영되지 않음
- **13~15번 시그니처:** 현재 구현에서는 6DOF 내부 상태 기반이며, 실제 레이더 적용 시에는 **비행경로각(γ) 변화율, 곡률, 횟가속도** 등 track 기반 대리변수로 대체하거나, micro-Doppler 등 추가 관측을 가정해야 한다.

### 10.3 향후 연구 방향

1. **딥러닝 적용:** CNN/RNN 기반 시계열 분류
2. **실시간 처리:** 스트리밍 데이터 처리 파이프라인
3. **다중 센서 융합:** 레이더, 적외선, 전자광학 센서 통합
4. **적대적 공격 대응:** 기만 기동에 대한 robustness 강화

### 10.4 프로젝트 성찰: 코딩과 프로그래밍의 차이 (정연우)

> "코딩은 문법을 따르는 것이고, 프로그래밍은 문제를 해결하는 것이다."

이 프로젝트를 통해 단순히 코드를 작성하는 것과 실제 물리 시스템을 구현하는 것의 차이를 체감하였다.

**코딩 수준의 접근:**
```python
# 그냥 공식 구현
def pitch_moment(alpha, q):
    return Cm_alpha * alpha + Cm_q * q
```

**프로그래밍 수준의 접근:**
```python
# 물리적 의미를 고려한 구현
def pitch_moment(alpha, q, V, rho, S, c, cg_position, cp_position):
    q_bar = 0.5 * rho * V**2
    static_margin = (cp_position - cg_position) / c
    if static_margin < 0:
        warnings.warn("정적 불안정! CP가 CG 앞에 있음")
    Cm = Cm_alpha * alpha + Cm_q * (q * c / (2*V))
    return q_bar * S * c * Cm
```

**팀 협업에서의 교훈:**
- **문서화의 중요성:** 변수 명명, 단위 주석이 디버깅 시간을 크게 단축
- **버전 관리:** Git을 통한 변경 이력 추적이 필수적
- **코드 리뷰:** 좌표계 오류 등 논리적 버그를 사전에 발견

---

## 11. 팀원 기여도

| 팀원 | 역할 | 주요 기여 |
|------|------|-----------|
| **박윤준** | 팀장, 물리 모델링 | 6DOF 운동방정식, TVC 시스템, FFT 동특성 분석, 보고서 작성 |
| **정연우** | 시각화, 검증 | 12채널 대시보드, 시스템 정합성 검토, FFT 분석 지원 |
| **김찬진** | 시그니처/ML 파이프라인 | 레이더 관측 기반 15개 시그니처 설계·추출, 데이터셋/정규화 파이프라인 구축, RandomForest 학습·평가 |
| **이준서** | UI/게임화 구현, KN-23 궤적 분석 | React 기반 미사일 식별 게임 UI, 웹 프론트엔드 개발, KN-23 저압궤도 시뮬레이션 검증 |

### 협업 도구

- **GitHub:** 버전 관리 및 코드 리뷰
- **Kakao Talk:** 실시간 소통

---

## 12. 오픈소스 참조 및 활용

### 12.1 RocketPy (브라질 대학 연구팀)

**GitHub:** https://github.com/RocketPy-Team/RocketPy

**참조 내용:**
- 대기 모델 (US Standard Atmosphere 1976)
- 공력계수 테이블 보간 방법
- 추력 커브 처리

### 12.2 JSBSim (NASA/Lockheed Martin 기원)

**GitHub:** https://github.com/JSBSim-Team/jsbsim

**참조 내용:**
- 6DOF 운동방정식 구조
- 공력 테이블 형식
- 제어 시스템 구조

**우리 구현과의 차이:**
- JSBSim은 일반 항공기용 → 우리는 탄도미사일 특화
- 연료 소모에 따른 CG 이동 우리가 더 상세히 구현

---

## 13. 학술 문헌 정리 (APA Style)

### 핵심 참고 문헌

1. **Zipfel, P. H.** (2007). *Modeling and Simulation of Aerospace Vehicle Dynamics* (2nd ed.). AIAA Education Series.
   - 쿼터니언 운동학 (Chapter 4)
   - 6DOF 운동방정식 (Chapter 5)

2. **Stevens, B. L., & Lewis, F. L.** (2003). *Aircraft Control and Simulation* (2nd ed.). Wiley.
   - 공력 도함수 정의
   - 제어 시스템 설계

3. **Siouris, G. M.** (2004). *Missile Guidance and Control Systems*. Springer.
   - 유도 법칙
   - TVC 모델링

4. **Fleeman, E. L.** (2012). *Missile Design and System Engineering*. AIAA Education Series.
   - 탄도미사일 성능 파라미터
   - 공력 형상 설계

### 북한 미사일 관련 자료

5. **Schiller, M., & Schmucker, R. H.** (2012). "A Review of the Nodong Missile." *Schmucker Technologie.*
   - Nodong 추력, 질량 데이터

6. **Lewis, J., & Schmerler, D.** (2021). "North Korea's KN-23 Missile." *Arms Control Wonk.*
   - KN-23 저압궤도 특성

### 레이더 기반 분류 및 시그니처 관련 문헌

7. **Singh, U. K., Padmanabhan, V., & Agarwal, A.** (2014). "Dynamic classification of ballistic missiles using neural networks and hidden Markov models." *Applied Soft Computing*, 19, 280–289.
   - 레이더 직접/파생 파라미터를 입력으로 분류
   - 본 프로젝트의 15개 시그니처 선정 원칙에 참조

8. **JHU APL Technical Digest** (Various). Parametric classification approaches / simulated signature database 기반 분류 모델 구성.
   - 시뮬레이션 데이터 기반 분류기 설계 흐름 참고

9. **Chen, V. C., et al.** (2006). "Micro-Doppler effect in radar: phenomenon, model, and simulation study." *IEEE Transactions on Aerospace and Electronic Systems*.
   - Time-frequency 기반 특징의 조건 민감성 및 계산비용 이슈
   - 본 프로젝트에서 트랙 기반 시그니처를 우선 채택한 근거

---

## 14. 감사의 글

본 프로젝트를 진행하며 도움을 주신 분들께 감사드립니다.

- **지도교수님:** 3DOF 참조 코드 제공 및 물리 모델링 조언
- **RocketPy 개발팀:** 오픈소스 코드 공개
- **JSBSim 커뮤니티:** 6DOF 구현 참고 자료

---
*본 보고서는 2025년 하반기 데이터과학 프로젝트의 최종 결과물입니다.*
