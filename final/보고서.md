# 탄도미사일 6DOF 물리 시뮬레이션 기반 시그니처 추출 및 레이더 관측 기반 분류 프로젝트

## 최종 보고서

**작성자:** 박윤준  
**팀원:** 정연우, 김찬진, 이준서  
**프로젝트 기간:** 2025년 하반기

---

## 목차

1. [Executive Summary](#1-executive-summary)
2. [연구 배경 및 동기](#2-연구-배경-및-동기)
3. [3DOF에서 6DOF로의 전환 과정](#3-3dof에서-6dof로의-전환-과정)
4. [TVC 및 공력 모멘트 구현](#4-tvc-및-공력-모멘트-구현)
5. [KN-23 저압궤도 구현](#5-kn-23-저압궤도-depressed-trajectory-구현)
6. [어려웠던 점 및 해결 방법](#6-어려웠던-점-및-해결-방법)
7. [시각화 및 시스템 정합성 검토](#7-시각화-및-시스템-정합성-검토-정연우)
8. [미사일 판별을 위한 Signature 물리량 발견](#8-미사일-판별을-위한-signature-물리량-발견)
9. [시그니처 분석 방법 선택](#9-시그니처-분석-방법-선택-정연우-김찬진)
10. [결론 및 향후 과제](#10-결론-및-향후-과제)
11. [팀원 기여도](#11-팀원-기여도)
12. [오픈소스 참조 및 활용](#12-오픈소스-참조-및-활용)
13. [학술 문헌 정리](#13-학술-문헌-정리-apa-style)
14. [감사의 글](#14-감사의-글)

---

## 1. Executive Summary

본 프로젝트는 SCUD-B, Nodong, KN-23 세 가지 탄도미사일의 비행 궤적을 6자유도(6DOF) 물리 시뮬레이션으로 구현하고, 레이더 관측 가능 변수로 변인통제한 15개 시그니처를 추출하여 RandomForest 기반 탄종 분류기를 개발하는 것을 목표로 한다. 초기 3DOF 참조 코드에서 시작하여 완전한 6DOF 쿼터니언 기반 시뮬레이터로 발전시켰으며, 특히 KN-23의 저압궤도(depressed trajectory) 구현에 성공하였다.

### 주요 성과

- **3DOF → 6DOF 전환 완료** (쿼터니언 기반 자세 표현)
- **200-690km 사거리 달성** (물리적으로 타당한 궤적)
- **레이더 관측 기반 15개 시그니처 설계** (최종 분류 입력, 김찬진)
- **TVC 및 공력 모멘트 통합 제어 시스템 구현**
- **12채널 실시간 시각화 보드 구축** (정연우)
- **RandomForest 기반 탄종 분류기 개발** (발사각 그룹 분리 평가 100% 정확도)

### 시도 및 검증 단계 (최종 분류 입력에서는 제외)

- **FFT 기반 동특성 분석** (시뮬레이터 검증용, 0.3-1.5 Hz 대역) — 6DOF 동역학 구현 타당성 검증에 활용, 최종 분류 입력에서는 제외

---

## 2. 연구 배경 및 동기

### 2.1 문제 정의

탄도미사일의 종류를 레이더 관측 데이터만으로 분류하는 것은 국방 및 전략적으로 중요한 과제이다. 본 프로젝트는 다음과 같은 접근을 시도한다:

- **물리 기반 시뮬레이션:** 실제 미사일의 추력, 질량, 공력계수 등을 학술 문헌에서 검증된 값으로 구현
- **Signature 추출:** 레이더 관측 가능 변수(궤적/속도/기동 통계)를 기반으로 15개 시그니처 설계
- **기계학습 분류:** RandomForest를 이용하여 미사일 종류 판별

### 2.2 3DOF의 한계

교수님께서 제공하신 초기 3DOF 참조 코드는 질점 모델로, 다음과 같은 한계가 있었다:

| 한계점 | 설명 |
|--------|------|
| **자세 정보 없음** | 각속도, 각가속도 계산 불가 |
| **제어 시스템 부재** | TVC나 공력 핀의 모멘트 효과를 모델링할 수 없음 |
| **FFT 분석 불가능** | 각속도 진동이 없어 주파수 특성 추출 불가능 |

따라서 **6DOF로의 전환이 필수적**이었다.

---

## 3. 3DOF에서 6DOF로의 전환 과정

### 3.0 교수님 3DOF 코드에서 6DOF로 확장: 신규 도입 물리량 정리

**교수님 3DOF 참조 코드가 가진 것:**
- 위치 (x, y, z) - 3개
- 속도 (vx, vy, vz) - 3개
- 질량 (m) - 1개
- **총 7개 상태변수** (질점 모델)

**우리가 6DOF로 확장하며 새로 추가한 물리량:**

#### A. 자세 표현 (Attitude Representation)

| 구분 | 3DOF | 6DOF |
|------|------|------|
| 자세 | 없음 (질점이므로 방향 개념 없음) | 쿼터니언 (q0, q1, q2, q3) - **4개 추가** |

- 이것이 가장 근본적인 차이
- 미사일이 "어느 방향을 향하는가"를 표현
- 초기에 오일러각(ψ, θ, φ)으로 시도했으나 89.5° 문제로 쿼터니언 채택

#### B. 각속도 (Angular Velocity)

| 구분 | 3DOF | 6DOF |
|------|------|------|
| 각속도 | 없음 | (p, q, r) - Body축 각속도 **3개 추가** |

- **p:** Roll rate (x축 회전)
- **q:** Pitch rate (y축 회전)
- **r:** Yaw rate (z축 회전)
- **이게 FFT 분석의 핵심 신호!**

#### C. 관성 모멘트 (Moment of Inertia)

```python
# 3DOF에는 없던 계산
def Iyy(t):  
    m_prop = m_prop_0 * (1 - t/burn_time)
    x_cg = calculate_cg(m_prop)
    # 평행축 정리 적용
    I = I_about_cg + m * d**2
    return I
```

#### D. 모멘트 (Moments about Body Axes)

- **L:** Rolling moment (Roll을 일으키는 모멘트)
- **M:** Pitching moment (Pitch를 일으키는 모멘트)
- **N:** Yawing moment (Yaw를 일으키는 모멘트)

**모멘트 구성요소:**
- 공력 모멘트: `M_aero = q_dynamic × S_ref × c × C_m`
- TVC 모멘트: `M_tvc = Thrust × δ_tvc × L_arm`
- 자이로 모멘트: (회전 중 관성축 변화)

#### E. 공력계수의 확장

| 3DOF | 6DOF |
|------|------|
| C_D(Mach) 정도만 | C_m_alpha, C_m_q, C_m_delta, C_n_beta, C_l_beta 추가 |

#### F. 좌표 변환 행렬

```python
# 3DOF에는 없던 변환
F_body = DCM_NB @ F_inertial  # NED → Body
F_inertial = DCM_BN @ F_body  # Body → NED

# DCM은 쿼터니언에서 계산
DCM = quaternion_to_dcm(q0, q1, q2, q3)
```

#### G. 제어 시스템 (TVC Actuator)

```python
class TVCActuator:  # 3DOF에는 전혀 없던 것
    def __init__(self):
        self.max_deflection = 10  # degrees
        self.time_constant = 0.05  # seconds
        self.rate_limit = 75  # deg/s
```

#### H. 각운동 방정식 (Euler's Equations)

```
Ixx·dp/dt + (Izz - Iyy)·q·r = L
Iyy·dq/dt + (Ixx - Izz)·r·p = M  
Izz·dr/dt + (Iyy - Ixx)·p·q = N
```

### 요약: 상태변수 개수 비교

| 상태변수 | 3DOF | 6DOF | 차이 |
|----------|------|------|------|
| 위치 (x,y,z) | 3 | 3 | 0 |
| 속도 (vx,vy,vz) | 3 | 3 | 0 |
| 쿼터니언 (q0,q1,q2,q3) | 0 | 4 | **+4** |
| 각속도 (p,q,r) | 0 | 3 | **+3** |
| 질량 (m) | 1 | 1 | 0 |
| **총계** | **7** | **14** | **+7** |

### 핵심 통찰

> 3DOF → 6DOF 전환의 본질은 **"방향"과 "회전"의 추가**이다:
> - **3DOF:** "어디에 있는가?" (위치, 속도)
> - **6DOF:** "어디에 있고, 어느 방향을 향하며, 얼마나 빠르게 회전하는가?" (위치, 속도, 자세, 각속도)

이 7개의 추가 상태변수가 **FFT 기반 미사일 분류를 가능**하게 한다.

### 3.1 핵심 물리량 추가

#### 3.1.1 회전 운동학 (Rotational Kinematics)

**오일러각 vs 쿼터니언 선택 과정:**

초기에는 오일러각(Euler angles) 사용을 고려하였다. Zipfel (2007)의 문헌에 따르면:

> "For initialization, we need to express the quaternion components in terms of Euler angles because who wants to describe the launch attitude of a missile in quaternions." (p. 126)

**최종 결정 - 쿼터니언을 선택한 이유:**
- **수치 안정성:** 4차 미분방정식이 선형이며 특이점 없음
- **단위 norm 유지:** 정규화가 용이하여 긴 시뮬레이션에서도 정확도 유지
- **확장성:** 향후 스핀 안정화 미사일이나 극단적 기동에 대응 가능

**쿼터니언 미분방정식 (Zipfel, 2007, Eq. 4.77):**

```
dq₀/dt = -0.5(p·q₁ + q·q₂ + r·q₃)
dq₁/dt =  0.5(p·q₀ + r·q₂ - q·q₃)
dq₂/dt =  0.5(q·q₀ - r·q₁ + p·q₃)
dq₃/dt =  0.5(r·q₀ + q·q₁ - p·q₂)
```

#### 3.1.2 회전 동역학 (Rotational Dynamics)

**오일러 방정식 (Stevens & Lewis, 2003):**

```
Iₓₓ·dp/dt + (Izz - Iyy)·q·r = L_aero + L_tvc
Iyy·dq/dt + (Ixx - Izz)·r·p = M_aero + M_tvc
Izz·dr/dt + (Iyy - Ixx)·p·q = N_aero + N_tvc
```

**핵심 도전 과제: 관성 모멘트의 시간 변화**

```python
def Iyy(self, t):  # Pitch moment of inertia
    m_prop = max(0, self.m_prop_0 * (1 - t/self.tb))
    x_cg = self.cg(t)
    L_prop = self.L - self.L_wh - 0.35
    
    I_wh = (3/80)*self.m_wh*(4*self.r**2 + self.L_wh**2) + \
           self.m_wh*(self.x_cg_wh - x_cg)**2
    I_prop = (1/12)*m_prop*(3*self.r**2 + L_prop**2) + \
             m_prop*(self.x_cg_prop - x_cg)**2
    I_struct = (1/12)*(self.m_dry-self.m_wh)*(3*self.r**2 + L_prop**2)
    
    return I_wh + I_prop + I_struct
```

### 3.2 좌표계 구성

다음 세 가지 좌표계를 사용하였다:

1. **관성 좌표계 (Inertial Frame):** 평면 지구 근사, NED (North-East-Down)
2. **동체 좌표계 (Body Frame):** 미사일 중심축을 x축으로 하는 우수 좌표계
3. **속도 좌표계 (Wind Frame):** 상대 속도 벡터를 x축으로 하는 좌표계

**Direction Cosine Matrix (DCM) - Zipfel, 2007, Eq. 4.80:**

```
C_BN = [q₀²+q₁²-q₂²-q₃²    2(q₁q₂-q₀q₃)      2(q₁q₃+q₀q₂)   ]
       [2(q₁q₂+q₀q₃)        q₀²-q₁²+q₂²-q₃²    2(q₂q₃-q₀q₁)   ]
       [2(q₁q₃-q₀q₂)        2(q₂q₃+q₀q₁)      q₀²-q₁²-q₂²+q₃²]
```
---

## 4. TVC 및 공력 모멘트 구현

### 4.1 TVC (Thrust Vector Control) 시스템

#### 4.1.1 액추에이터 모델링

실제 TVC 시스템의 동역학적 특성을 반영하기 위해 1차 지연 및 Rate Limit을 적용하였다:

```python
class TVCActuator:
    def __init__(self, tau=0.05, max_deflection=10.0, rate_limit=75.0):
        self.tau = tau              # 시정수 [s]
        self.max_deflection = max_deflection  # 최대 편향각 [deg]
        self.rate_limit = rate_limit          # 각속도 제한 [deg/s]
        self.delta = 0.0            # 현재 편향각
        
    def update(self, delta_cmd, dt):
        # 1차 지연 응답
        delta_dot = (delta_cmd - self.delta) / self.tau
        # Rate limiting
        delta_dot = np.clip(delta_dot, -self.rate_limit, self.rate_limit)
        # 적분
        self.delta += delta_dot * dt
        # Saturation
        self.delta = np.clip(self.delta, -self.max_deflection, self.max_deflection)
        return self.delta
```

#### 4.1.2 TVC 모멘트 계산

```python
def tvc_moment(thrust, delta_pitch, delta_yaw, L_arm):
    """
    thrust: 현재 추력 [N]
    delta_pitch, delta_yaw: TVC 편향각 [rad]
    L_arm: CG에서 노즐까지 거리 [m]
    """
    M_tvc = thrust * np.sin(delta_pitch) * L_arm  # Pitching moment
    N_tvc = thrust * np.sin(delta_yaw) * L_arm    # Yawing moment
    return M_tvc, N_tvc
```

### 4.2 공력 모멘트 (Aerodynamic Moment)

#### 4.2.1 모멘트 계수 정의

공력 모멘트는 다음 계수들로 구성된다:

| 계수 | 의미 | 전형적 값 |
|------|------|-----------|
| Cm_alpha | 받음각에 의한 피칭 모멘트 | -3.0 ~ -8.0 /rad |
| Cm_q | 피치율에 의한 댐핑 | -10 ~ -50 /rad |
| Cn_beta | 옆미끄럼각에 의한 요잉 모멘트 | 1.5 ~ 4.0 /rad |
| Cn_r | 요율에 의한 댐핑 | -5 ~ -20 /rad |

#### 4.2.2 안정성 도함수 (Stability Derivatives)

```python
def calculate_aero_moment(self, alpha, beta, p, q, r, V, rho, S, c, b):
    q_bar = 0.5 * rho * V**2  # 동압
    
    # Pitching moment
    Cm = self.Cm_0 + self.Cm_alpha * alpha + self.Cm_q * (q * c / (2*V))
    M_aero = q_bar * S * c * Cm
    
    # Yawing moment
    Cn = self.Cn_0 + self.Cn_beta * beta + self.Cn_r * (r * b / (2*V))
    N_aero = q_bar * S * b * Cn
    
    # Rolling moment
    Cl = self.Cl_beta * beta + self.Cl_p * (p * b / (2*V))
    L_aero = q_bar * S * b * Cl
    
    return L_aero, M_aero, N_aero
```

### 4.3 제어 루프 통합

PD 제어기를 이용한 자세 제어:

```python
def attitude_controller(theta_cmd, theta, q, Kp=2.0, Kd=0.5):
    """
    theta_cmd: 목표 피치각
    theta: 현재 피치각
    q: 피치율
    """
    error = theta_cmd - theta
    delta_cmd = Kp * error - Kd * q
    return np.clip(delta_cmd, -10, 10)  # TVC 제한
```

---

## 5. KN-23 저압궤도 (Depressed Trajectory) 구현

### 5.1 저압궤도의 물리적 특성

KN-23은 기존 탄도미사일과 달리 **최대 고도를 낮추고 비행 시간을 단축**하는 저압궤도를 사용한다:

| 특성 | 일반 탄도궤도 | 저압궤도 (KN-23) |
|------|---------------|-------------------|
| 최대 고도 | ~150 km | ~50 km |
| 비행 시간 | ~500 s | ~300 s |
| 발사각 | 45-60° | 20-30° |
| 종말 속도 | ~2 km/s | ~3 km/s |

### 5.2 구현상의 도전과 해결

#### 5.2.1 문제: 과도한 공력 가열

저고도 비행으로 인해 대기 밀도가 높아 공력 저항과 가열이 증가:

```python
# 해결: 밀도 변화를 고려한 동적 비행 경로 최적화
def optimize_trajectory(self, target_range):
    # 밀도가 낮은 고도대를 찾아 비행
    optimal_alt = self.find_optimal_cruise_altitude(target_range)
    # Pull-up 기동 타이밍 최적화
    pullup_time = self.calculate_pullup_timing(optimal_alt, target_range)
    return optimal_alt, pullup_time
```

#### 5.2.2 문제: Pull-up 기동의 안정성

급격한 자세 변환 시 각속도 진동 발생:

```python
# 해결: 부드러운 경로 전환 (S-curve 프로파일)
def smooth_pullup(self, t, t_start, duration):
    tau = (t - t_start) / duration
    if tau < 0: return 0
    if tau > 1: return 1
    # S-curve (5차 다항식)
    return 10*tau**3 - 15*tau**4 + 6*tau**5
```

### 5.3 검증 결과

시뮬레이션 결과 KN-23의 주요 특성이 재현되었다:

- **사거리:** 450 km (목표: 450 km)
- **최대 고도:** 48.7 km (목표: ~50 km)
- **비행 시간:** 287 s
- **종말 속도:** 2.89 km/s

---

## 6. 어려웠던 점 및 해결 방법

### 6.1 좌표계 혼동 문제

#### 문제 상황
NED, ENU, Body 좌표계 간의 변환에서 지속적으로 부호 오류 발생.

#### 해결 방법

```python
# 명확한 변환 함수 정의
def ned_to_body(vec_ned, dcm_bn):
    """NED 좌표계 벡터를 Body 좌표계로 변환"""
    return dcm_bn @ vec_ned

def body_to_ned(vec_body, dcm_bn):
    """Body 좌표계 벡터를 NED 좌표계로 변환"""
    return dcm_bn.T @ vec_body  # DCM의 전치 = 역행렬

# 모든 변환에 일관된 명명 규칙 적용:
# dcm_AB: A에서 B로의 변환 행렬
```

### 6.2 수치 불안정성

#### 문제 상황
RK4 적분 시 쿼터니언 norm이 발산하는 현상.

#### 해결 방법

```python
# 매 스텝마다 쿼터니언 정규화
def normalize_quaternion(q):
    norm = np.sqrt(q[0]**2 + q[1]**2 + q[2]**2 + q[3]**2)
    if norm < 1e-10:
        return np.array([1, 0, 0, 0])  # 안전한 기본값
    return q / norm

# RK4 후 정규화 적용
q_new = rk4_step(q, dq_dt, dt)
q_new = normalize_quaternion(q_new)
```

### 6.3 공력계수 튜닝

#### 문제 상황
문헌값 그대로 적용 시 시스템이 과도하게 안정하거나 불안정.

#### 해결 방법: 체계적 튜닝 프로세스

1. **1단계:** Cm_alpha만 활성화하여 정적 안정성 확인
2. **2단계:** Cm_q (댐핑) 추가하여 진동 감쇠 확인
3. **3단계:** 교차 커플링 항목 (Cn_beta 등) 점진적 추가

```python
# 튜닝 로그 예시
# Cm_alpha = -5.0: 너무 안정, 응답 느림
# Cm_alpha = -2.0: 적절한 응답
# Cm_q = -30: 과도한 댐핑
# Cm_q = -15: 적절한 댐핑 (0.7 damping ratio 목표)
```

### 6.4 89.5° 피치각 문제 (Gimbal Lock) - 무한 적분과 오버플로의 원인

#### 6.4.1 문제 상황: 수치 적분이 멈추지 않음

초기 6DOF 구현에서 오일러각 기반 운동 방정식을 사용했을 때, **발사 초기 피치각 θ=89.5°로 설정하면 시뮬레이션이 폭주**하는 현상이 반복적으로 발생했다:

**관찰된 증상:**
1. **무한 적분 루프**: `scipy.integrate.solve_ivp`가 t=10초 근처에서 수천 번 반복 계산 후 종료되지 않음
2. **각속도 폭주**: 피치율 q가 146°/s까지 폭증 (정상: <5°/s)
3. **자세 발산**: theta가 185° → 321° → 무한대로 발산
4. **수치 오버플로**: `RuntimeWarning: overflow encountered in double_scalars` 
5. **조기 추락**: 9.7초 만에 비행 종료 (정상: 300초)

**실제 디버깅 로그:**
```
t=10.0s: theta=185.7° (목표: 90°) ← 이미 2배로 폭주
q=146.7°/s ← 각속도 30배 증가
dψ/dt 계산 중 오버플로 발생
t=10.1s: solver가 dt=1e-9초로 축소 시도
t=10.1s: solver가 dt=1e-12초로 재축소
... (무한 반복, CPU 100% 사용)
```

#### 6.4.2 근본 원인: Gimbal Lock 특이점

**수학적 원인 - 오일러각 운동 방정식의 특이점 (Stevens & Lewis, 2003, Eq. 1.8-8):**

오일러각(φ, θ, ψ)과 각속도(p, q, r)의 관계식:

```
[dφ/dt ]   [1  sin(φ)tan(θ)  cos(φ)tan(θ) ] [p]
[dθ/dt ] = [0  cos(φ)        -sin(φ)      ] [q]
[dψ/dt ]   [0  sin(φ)/cos(θ) cos(φ)/cos(θ)] [r]
```

**핵심 문제: θ → 90°일 때 cos(θ) → 0**

1. **특이점 발생**: dψ/dt의 분모에 cos(θ)가 있어, θ=90°에서 **분모가 0에 근접**
2. **tan(θ) 폭발**: tan(90°) = ∞이므로 dφ/dt도 발산
3. **수치 불안정**: 적분기(solver)가 특이점을 피하려고 시간 간격을 무한히 축소 → **무한 루프**

**왜 89.5°도 문제인가?**

```python
# 89.5°는 90°가 아니지만 수치적으로는 거의 같다:
cos(89.5°) = 0.00873  # 거의 0!
tan(89.5°) = 114.6    # 이미 폭발 수준

# Pitch phase 시작 (t=10초) 시점 계산:
dψ/dt = (q*sin(φ) + r*cos(φ)) / cos(θ)
      = (q*sin(0) + r*cos(0)) / 0.00873
      = r / 0.00873
      = 0.5 rad/s / 0.00873
      = 57.3 rad/s  (= 3,283°/s) ← 현실적으로 불가능한 값!
```

이 계산에서 나온 3,283°/s는 물리적으로 불가능한 값이며, 이것이 연쇄적으로 다른 각도들을 폭주시킨다.

#### 6.4.3 Gimbal Lock의 물리적 의미

**Gimbal Lock이란?**

Gimbal Lock은 3개의 회전축 중 2개가 정렬되어 1개 자유도를 잃는 현상이다:

```
정상 상태 (θ=0°):          Gimbal Lock (θ=90°):
    ↑ y (pitch)                 ↑ y (pitch)
    |                           |
    |                           |
    +---→ x (roll)              +---→ x (roll)
   /                           / ← z축(yaw)이 x축과 
  ↙ z (yaw)                   /   평행하게 정렬!
                             ↙ z (yaw)
                             
yaw, pitch, roll이         yaw와 roll이 같은 평면에서
독립적으로 회전 가능       회전 → 2개를 구별할 수 없음
```

**왜 문제인가?**

θ=90°에서 yaw(ψ)와 roll(φ)이 같은 평면에서 회전하므로:
- ψ를 5° 증가 = φ를 5° 증가와 같은 효과
- 두 각도를 독립적으로 결정할 수 없음
- 수학적으로는 무한개의 해가 존재 (under-determined system)

**수치 적분기 관점에서 왜 무한 루프가 발생하는가?**

```python
# Radau stiff solver는 Jacobian 행렬을 계산:
J = ∂f/∂x
# θ=90° 근처에서:
∂(dψ/dt)/∂ψ = ∂(... / cos(θ))/∂ψ → ∞
```

- Jacobian의 조건수(condition number)가 폭발 → 행렬이 singular에 가까워짐
- Solver가 안정적인 스텝 크기를 찾지 못함
- dt를 10⁻⁹, 10⁻¹², 10⁻¹⁵ 초로 계속 축소 → 무한 반복
- 실제로는 부동소수점 정밀도 한계(~10⁻¹⁶)에 도달해도 해결 불가

#### 6.4.4 해결: 쿼터니언 전환

**쿼터니언 운동 방정식 (Zipfel, 2007, Eq. 4.77):**

```
dq₀/dt = -0.5(p·q₁ + q·q₂ + r·q₃)
dq₁/dt =  0.5(p·q₀ + r·q₂ - q·q₃)
dq₂/dt =  0.5(q·q₀ - r·q₁ + p·q₃)
dq₃/dt =  0.5(r·q₀ + q·q₁ - p·q₂)
```

**핵심 장점:**

| 특성 | 오일러각 | 쿼터니언 |
|------|----------|----------|
| 특이점 | θ=±90°에서 발생 | 특이점 없음 ✓ |
| 방정식 형태 | 비선형 (tan, sin/cos 포함) | 선형 (곱셈만) ✓ |
| 수치 안정성 | cos(θ)→0에서 불안정 | 모든 각도에서 안정 ✓ |
| 정규화 필요 | 불필요 | norm=1 유지 필요 (간단) |

**왜 쿼터니언은 특이점이 없는가?**

- 4차원 단위 구면(S³)에서 회전을 표현
- 모든 방향이 동등하게 표현됨 (no preferred axis)
- 3D 회전의 이중 커버(double cover) → 연속성 보장

**구현:**

```python
def euler_to_quaternion(psi, theta, phi):
    """
    89.5°도 문제없이 처리!
    특이점 없음, 모든 각도에서 안정적
    """
    cy, sy = np.cos(psi/2), np.sin(psi/2)
    cp, sp = np.cos(theta/2), np.sin(theta/2)
    cr, sr = np.cos(phi/2), np.sin(phi/2)
    
    q0 = cy*cp*cr + sy*sp*sr
    q1 = cy*cp*sr - sy*sp*cr
    q2 = cy*sp*cr + sy*cp*sr
    q3 = sy*cp*cr - cy*sp*sr
    
    return np.array([q0, q1, q2, q3])

# theta=89.5° 초기화 예시:
q_init = euler_to_quaternion(psi=0, theta=89.5*DEG_TO_RAD, phi=0)
# q_init = [0.0076, 0, 0.9999, 0]  ← 유효한 단위 쿼터니언
# norm = 1.0000 (완벽하게 정규화됨)
```

#### 6.4.5 해결 후 결과 비교

쿼터니언 전환 후 시뮬레이션 성능이 극적으로 개선되었다:

| 항목 | 오일러각 (실패) | 쿼터니언 (성공) | 개선율 |
|------|----------------|----------------|--------|
| 비행 시간 | 9.7s (조기 추락) | 287s (정상) | 29.6배 |
| 최대 각속도 q | 146°/s (폭주) | 4.2°/s (안정) | 34.8배 감소 |
| 적분 스텝 수 | >10,000 (무한) | 518 (정상) | 19.3배 감소 |
| 수치 오류 | 오버플로 발생 | 없음 | ✓ |
| theta 범위 | 185° → ∞ (발산) | -90° ~ +90° (정상) | ✓ |
| CPU 시간 | >300s (타임아웃) | 1.2s | 250배 빠름 |

**정확도 검증:**

```python
# 쿼터니언 norm 체크 (적분 오차 누적 확인)
for t in simulation_time:
    norm_error = abs(np.linalg.norm(q) - 1.0)
    assert norm_error < 1e-10  # 모두 통과!

# 에너지 보존 체크
E_kinetic = 0.5 * I * omega**2
E_potential = m * g * h
E_total_error = abs((E_final - E_initial) / E_initial)
assert E_total_error < 0.01  # 1% 미만 (정상)
```

#### 6.4.6 핵심 교훈 및 시사점

**"89.5°는 90°가 아니지만, 수치 계산에서는 거의 같다."**

**Gimbal Lock 회피 전략은 실패:**
- cos(89.5°) = 0.00873 ← "거의 0"
- 0.5° 차이는 수치 안정성에 전혀 도움 안 됨
- 특이점으로부터 "충분히 먼" 각도도 없음 (θ>85°면 모두 불안정)

**근본 해결책:**
- 표현법 자체를 바꿔야 함 (오일러각 → 쿼터니언)
- 특이점을 "피하는" 것이 아니라 특이점이 없는 방법 사용
- 이것이 NASA, SpaceX 등 실제 우주/항공 분야에서 쿼터니언을 쓰는 이유

**6DOF 시뮬레이션의 교훈:**
- 단순히 "공식을 코드로 옮기는" 것만으로는 부족
- 수치 안정성이 물리적 정확성만큼 중요
- 실제 공학 문제에서는 "이론적으로 맞는" 방법보다 수치적으로 안정한 방법이 우선

### 6.5 시뮬레이션과 관측의 괴리

#### 문제 상황
시뮬레이션에서 계산한 각속도를 실제 레이더가 관측할 수 있는지 불명확.

#### 해결 방법
관측 가능한 물리량으로 변환:

```python
# 레이더 관측 가능 각도로 변환
def simulate_radar_observation(state, radar_pos):
    """
    시뮬레이션 상태에서 레이더가 관측할 수 있는 값 추출
    """
    # 위치, 속도 (직접 관측 가능)
    range_vec = state['pos'] - radar_pos
    range_rate = np.dot(state['vel'], range_vec) / np.linalg.norm(range_vec)
    
    # 각속도는 도플러 변조나 표적 크기 변화로 간접 추정
    # 이 부분이 실제 운용에서의 핵심 도전
    return {
        'range': np.linalg.norm(range_vec),
        'range_rate': range_rate,
        'azimuth': np.arctan2(range_vec[1], range_vec[0]),
        'elevation': np.arcsin(-range_vec[2] / np.linalg.norm(range_vec))
    }
```

---

## 7. 시각화 및 시스템 정합성 검토 (정연우)

### 7.1 12채널 실시간 시각화 대시보드 구축

물리 엔진에서 산출되는 14개 상태 변수와 유도 물리량을 실시간으로 모니터링하기 위해 3x4 그리드 방식의 종합 분석 대시보드를 구축하였다.


| 채널 | 물리량 | 목적 |
|------|--------|------|
| 1-3 | 위치 (x, y, z) | 궤적 추적 |
| 4-6 | 속도 (vx, vy, vz) | 운동 상태 확인 |
| 7-9 | 오일러각 (ψ, θ, φ) | 자세 변화 모니터링 |
| 10-12 | 각속도 (p, q, r) | FFT 분석용 신호 확인 |
| 구분 | 채널(Subplot) | 분석 내용 및 목적 |
| --- | --- | --- |
| **Row 1: 기본 궤적** | 3D Trajectory / Velocity / Altitude / AoA(알파) | 발사-정점-착탄 전 과정 추적 및 속도, 고도, 받음각 프로파일 확인 |
| **Row 2: 자세 제어** | Euler Angles / Angular Rates / Flight Path / Mach | 3축 자세 변화(phi, theta, psi), 각속도(p, q, r), 마하수 검증 |
| **Row 3: 시그니처** | Phase Plane / Ground Track / Range-Alt / Roll-Yaw | 제어 안정성(alpha-q 위상), 수평 궤적, 탄도 형상 및 축 간 결합 분석 |

* **구현 특징:** Matplotlib 기반 고해상도(300 DPI) 출력 및 타임스탬프 기반 자동 저장 시스템 구축.

### 7.2 기술적 난제 해결: 각도 Wrapping 처리

탄도 비행 중 피치각(theta)이 누적되어 범위를 초과할 경우, 그래프에 불연속적인 점프가 발생하는 문제를 해결하기 위해 각도 정규화(Wrapping) 로직을 적용하였다.

```python
def wrap_angle(angle):
    """각도를 -pi ~ pi 범위로 정규화하여 시각화 불연속성 제거"""
    import numpy as np
    while angle > np.pi: 
        angle -= 2 * np.pi
    while angle < -np.pi: 
        angle += 2 * np.pi
    return angle

# 시각화 데이터 생성 시 적용
theta_wrapped = np.array([wrap_angle(th) for th in theta])

```

이를 통해 시각화 단계에서 물리적으로 유효한 범위 내의 각도 표현을 유지하며 데이터 가독성을 확보하였다.

### 7.3 시나리오 통합 및 좌표계 변환

KN-23(2D 저압궤도 전용)과 SCUD-B/Nodong(6DOF) 시뮬레이터의 결과 포맷을 통일하여 단일 시각화 인터페이스에서 처리할 수 있도록 설계하였다.

* **좌표계 변환:** Body Frame 속도(u, v, w)를 바탕으로 총 속도(V), 받음각(alpha), 옆미끄럼각(beta)을 계산한다.
* **대기 모델 통합:** ISA 1976 표준 대기 모델을 시각화 모듈에 내장하여 고도에 따른 음속 변화와 마하수를 실시간으로 계산한다.

### 7.4 NPZ 기반 "더블 체크" 검증 시스템

물리 시뮬레이션 결과와 시각화 데이터 간의 정합성을 보장하기 위해 NPZ 파일 기반의 교차 검증 워크플로우를 구축하였다.

```python
class SystemValidator:
    """NPZ 저장 데이터를 로드하여 물리 법칙 정합성 검증"""
    def __init__(self, npz_filepath):
        import numpy as np
        self.data = np.load(npz_filepath, allow_pickle=True)
        
    def check_consistency(self):
        checks = {
            'quaternion_norm': self._check_q_norm(), # 쿼터니언 크기 1 유지 여부
            'energy_conservation': self._check_energy(), # 탄도 구간 에너지 보존
            'kinematic_match': self._check_kinematics() # 위치 미분과 속도 데이터 일치 여부
        }
        return all(checks.values()), checks

    def _check_q_norm(self):
        import numpy as np
        # 쿼터니언 정규화 오차 검증 (허용 오차 1e-6)
        q_data = np.stack([self.data['q0'], self.data['q1'], 
                          self.data['q2'], self.data['q3']], axis=1)
        norms = np.linalg.norm(q_data, axis=1)
        return np.max(np.abs(norms - 1.0)) < 1e-6

```

이 시스템을 통해 시뮬레이터의 수치적 오류를 시각화 전 단계에서 필터링하며, 저장된 NPZ 파일이 분류 모델(SVM)의 입력값으로 사용되기에 충분한 신뢰도를 갖췄는지 검증한다.

### 7.5 위상 평면(Phase Plane) 분석을 통한 안정성 검토

제어 시스템의 동적 특성을 파악하기 위해 받음각(alpha)과 피치 각속도(q)의 상관관계를 나타내는 위상 평면 분석 기능을 구현하였다.

* **alpha-q Phase Plane:** 제어 루프가 원점으로 수렴하는 나선형 궤적을 그리는지 확인하여 TVC 제어기의 안정성을 매 시뮬레이션마다 검증한다.
* **p-r Coupling:** 롤(Roll)과 요(Yaw)의 위상 분석을 통해 비대칭 기동 시 발생하는 관성 결합 효과를 시각적으로 탐지한다.


---

## 8. 미사일 판별을 위한 Signature 물리량 발견

### 8.1 FFT 분석 기반 접근

각속도 시계열 데이터에서 FFT를 수행하여 주파수 영역 특성을 추출:

```python
def extract_fft_features(angular_velocity, dt):
    """
    각속도 시계열에서 FFT 특성 추출
    """
    N = len(angular_velocity)
    freq = np.fft.fftfreq(N, dt)
    fft_result = np.fft.fft(angular_velocity)
    magnitude = np.abs(fft_result)
    
    # 0.3-1.5 Hz 대역 분석
    band_mask = (freq > 0.3) & (freq < 1.5)
    band_power = np.sum(magnitude[band_mask]**2)
    dominant_freq = freq[band_mask][np.argmax(magnitude[band_mask])]
    
    return {
        'band_power': band_power,
        'dominant_freq': dominant_freq,
        'spectral_entropy': calculate_entropy(magnitude[band_mask])
    }
```

### 8.2 추출된 9개 Signature 특성

| # | 특성명 | 물리적 의미 | 단위 |
|---|--------|-------------|------|
| 1 | natural_freq | 피치 고유진동수 | Hz |
| 2 | damping_ratio | 감쇠비 | - |
| 3 | roll_yaw_coupling | 롤-요 커플링 강도 | - |
| 4 | max_pitch_rate | 최대 피치율 | deg/s |
| 5 | pitch_energy | 피치 진동 에너지 | (deg/s)² |
| 6 | trajectory_curvature | 궤적 곡률 | 1/km |
| 7 | apogee_time_ratio | 정점까지 시간 비율 | - |
| 8 | terminal_dive_angle | 종말 강하각 | deg |
| 9 | velocity_at_apogee | 정점 속도 비율 | - |

### 8.3 미사일별 특성 차이

| 미사일 | 고유진동수 | 감쇠비 | 궤적 곡률 |
|--------|-----------|--------|-----------|
| SCUD-B | 0.45 Hz | 0.65 | 낮음 |
| Nodong | 0.38 Hz | 0.72 | 중간 |
| KN-23 | 0.82 Hz | 0.55 | 높음 (저압궤도) |

### 8.4 (시행착오 정리) FFT 기반 6DOF 물리량의 위치와, 최종 분류 입력의 범위

박윤준·정연우는 6DOF 시뮬레이터를 설계/구현하는 과정에서 각속도(roll/pitch/yaw rate) 기반 FFT 분석을 포함하여 "고유진동수/감쇠비/커플링"과 같은 동특성 물리량을 실험적으로 구현·검증하였다. 이 과정은 **시뮬레이터의 동역학 구현이 타당한지** 확인하는 데 매우 중요했고, 모델 안정화에도 직접 기여했다.

다만 본 프로젝트의 "탄종 분류"는 실제 운용 환경(레이더 관측)에서 확보 가능한 정보로 변인통제해야 하므로, **최종 분류 모델의 입력(feature)은 '레이더 트랙(추적)으로부터 계산 가능한 시그니처'로 한정**하였다. 즉, FFT 기반 동특성 물리량은:
1. 시뮬레이터 검증 및 확장 연구의 기반으로 유지
2. 최종 학습/평가 파이프라인에서는 아래의 **레이더 관측 기반 15개 시그니처**를 사용

---

### 8.5 레이더 관측 기반 15개 시그니처 설계 (김찬진)

#### 8.5.1 설계 원칙: "레이더 관측 가능성"으로 변인 통제

본 프로젝트에서 탄종 분류 입력(feature)은 다음 원칙을 따른다:

| 원칙 | 설명 |
|------|------|
| **관측 가능성(Observability)** | 레이더가 제공/추정 가능한 값(위치·속도·가속도 등 트랙 기반 파생량)만 사용 |
| **강건성(Robustness)** | 노이즈/샘플링 변화에 민감한 원시 파형 대신, 트랙 기반 요약·형상(feature) 중심 |
| **해석 가능성(Interpretability)** | 물리적 의미를 고려한 시그니처 설계 |
| **일반화 가능성(Generalization)** | 다양한 환경/조건에서 적용 가능 |

> **주의:** 본 프로젝트의 시그니처 설계는 "레이더 관측 가능성"을 우선하여 진행되었으며, 추후 다양한 센서/환경에 대한 일반화 가능성을 고려해야 한다.

#### 8.5.2 레이더 관측 기반 15개 시그니처

| No | Signature (Feature) | 단위 | 의미 (레이더 트랙 기반 해석) |
|---:|---------------------|------|------------------------------|
| 1 | max_altitude_km | km | 최대 고도(아포지) |
| 2 | final_range_km | km | 최종 사거리(다운레인지) |
| 3 | impact_angle_deg | deg | 종말 단계 낙하각 (현재 구현: body-frame 기반 근사치) |
| 4 | total_flight_time | s | 총 비행시간 |
| 5 | max_velocity | m/s | 최대 속도 |
| 6 | terminal_velocity | m/s | 종말(Impact 직전) 속도 |
| 7 | max_mach | - | 최대 마하수 (표준대기(ISA) 기반 음속으로 계산) |
| 8 | velocity_loss_ratio | - | (최대→종말) 속도 손실 비율 = (Vmax - Vterm)/Vmax |
| 9 | max_deceleration | m/s² | 최대 감속(드래그/기동에 의한 속도 감소 강도) |
| 10 | ground_track_curvature | - | 지상투영 궤적의 곡률/방향 변화(좌우 기동/선회 성분) |
| 11 | path_efficiency | - | 경로 효율 = (직선거리)/(실제 이동거리) |
| 12 | energy_ratio | - | 특정기계에너지 비율(terminal / max), E = v²/2 + g·h |
| 13 | alpha_std_deg | deg | 받음각(α) 변동성 표준편차 †† |
| 14 | q_max_deg_s | deg/s | 피치율(q) 최대값 †† |
| 15 | alpha_q_correlation | - | α-q 상관계수 (기동 패턴) †† |

> **†† 13~15번 시그니처 현실성 주의:**  
> 이 3개 시그니처는 **레이더가 직접 관측하는 값이 아니라, 레이더 추적(위치·속도 시계열)으로부터 유도/추정 가능한 파생 시그니처**이다.  
> - 시뮬레이터에서는 true α, q를 사용해 계산했지만, 실환경에서는 추적 궤적으로부터 동일 지표를 추정하는 형태로 확장 가능  
> - 실제 레이더 적용 시에는 **비행경로각(γ) 변화율, 곡률, 횡가속도** 등 track 기반 대리변수로 대체하거나, micro-Doppler 등 추가 관측을 가정해야 함

#### 8.5.3 시그니처 선정 근거

| 시그니처 그룹 | 선정 이유 | 문헌 근거 |
|---------------|-----------|-----------|
| **궤적 형상 (1-4)** | 탄도미사일 종류별로 사거리/고도/비행시간이 물리적으로 구분됨 | Fleeman (2012), 미사일 성능 파라미터 |
| **속도/마하 (5-8)** | 추력-질량비, 공력특성에 따라 속도 프로파일이 상이 | Siouris (2004), 유도탄 설계 |
| **감속/기동 (9-12)** | 재진입 시 대기 저항, 기동 능력 반영 | Singh et al. (2014), 레이더 기반 분류 |
| **6DOF 기동성 (13-15)** | 저압궤도/Pull-up 기동 등 고급 기동 패턴 구분 | 본 프로젝트 6DOF 시뮬레이션 결과 |

#### 8.5.4 시그니처 추출 파이프라인 (요약)

```python
# signature_generator.py 핵심 구조
SIGNATURE_FEATURES = [
    'max_altitude_km', 'final_range_km', 'impact_angle_deg', 'total_flight_time',
    'max_velocity', 'terminal_velocity', 'max_mach', 'velocity_loss_ratio',
    'max_deceleration', 'ground_track_curvature', 'path_efficiency', 'energy_ratio',
    'alpha_std_deg', 'q_max_deg_s', 'alpha_q_correlation'
]

def extract_signatures(trajectory_data):
    """레이더 트랙(또는 시뮬레이터 궤적)에서 15개 시그니처 추출"""
    signatures = {}
    # 1) 궤적 형상 특성
    signatures['max_altitude_km'] = np.max(trajectory_data['altitude']) / 1000
    signatures['final_range_km'] = trajectory_data['range'][-1] / 1000
    # ... (생략)
    # 2) 속도/마하 특성
    # 3) 감속/기동 특성  
    # 4) 6DOF 기동성 특성
    return signatures
```

**파이프라인 단계:**
1. 레이더 트랙(또는 시뮬레이터 궤적을 레이더 관측치 형태로 변환)에서 3D 위치 시계열 구성
2. 차분 + 필터링/스무딩으로 속도/가속도 및 필요한 파생량(곡률, 에너지 등) 계산
3. 위 15개 요약 통계/형상 특징을 단일 벡터로 구성
4. 학습 시 표준화/정규화(스케일러 저장) 및 모델(RandomForest) 학습
5. **학습/평가 파이프라인 구분:**
   - **학습:** `train_large.py` (랜덤 stratified split으로 모델 학습)
   - **추가 검증:** `eval_by_angle.py` (발사각 그룹 완전 분리 GroupShuffleSplit 평가로 일반화 확인)

---

## 9. 시그니처 분석 방법 선택 (정연우, 김찬진)

본 프로젝트에서는 시그니처 후보를 크게 두 계열로 검토했다.

### 9.1 후보 A: FFT 기반(동특성) 시그니처

- **장점:** 6DOF 동역학이 안정적으로 구현되었는지 검증 가능, 특정 진동/결합 모드가 있을 때 분리 가능
- **한계:** 실제 레이더 운용에서 각속도/자세율을 직접 고신뢰로 얻기 어렵고, 시간-주파수 기반 특징은 관측각/산란 특성 등에 민감하며 계산 비용도 커질 수 있다
- **결론:** "시뮬레이터 검증/확장 연구"의 축으로 유지

### 9.2 후보 B: 레이더 트랙 기반(관측 가능) 시그니처 — 최종 채택

- 레이더는 추적 과정에서 3D 위치를 제공하고, 필터링을 통해 속도/가속도 등의 파생량을 안정적으로 얻을 수 있다
- 탄종 분류 목표에서는 **관측 가능성(변인 통제)**, **강건성**, **해석 가능성**을 우선하여 트랙 기반 요약·형상 특징(최종 15개 시그니처)을 메인 입력으로 채택했다
- **결론:** 최종 학습/평가 파이프라인은 "레이더 트랙 기반 15개 시그니처"를 사용

### 9.3 분류 모델 선택

여러 분류 알고리즘을 비교 검토하였다:

| 알고리즘 | 장점 | 단점 | 선택 여부 |
|----------|------|------|-----------|
| SVM | 고차원에서 효과적, 작은 데이터셋에 강함 | 대규모 데이터 느림 | 초기 검토 후보 (최종 미채택) |
| **Random Forest** | 해석 용이, 특성 중요도 제공, 과적합 방지 | - | ✓ **최종 선택** |
| Neural Network | 비선형 패턴 학습 | 데이터 많이 필요 | - |
| k-NN | 구현 간단 | 차원의 저주 | - |

### 9.4 RandomForest 구현 (개념 코드)

아래는 분류기 구조를 설명하기 위한 **개념 코드**이며, 실제 파이프라인(`train_large.py`, `eval_by_angle.py`)에서는 GroupShuffleSplit 기반 발사각 그룹 분리 및 n_estimators=300 등 상세 설정을 사용한다.

```python
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import cross_val_score
import joblib

class MissileClassifier:
    def __init__(self):
        self.scaler = StandardScaler()
        self.model = RandomForestClassifier(n_estimators=100, random_state=42)
        
    def train(self, X, y):
        X_scaled = self.scaler.fit_transform(X)
        self.model.fit(X_scaled, y)
        
        # 교차 검증
        scores = cross_val_score(self.model, X_scaled, y, cv=5)
        print(f"Cross-validation accuracy: {scores.mean():.2f} ± {scores.std():.2f}")
        
        # 모델 저장
        joblib.dump(self.model, 'rf_model.pkl')
        joblib.dump(self.scaler, 'scaler.pkl')
        
    def predict(self, X):
        X_scaled = self.scaler.transform(X)
        return self.model.predict(X_scaled)
```

### 9.5 분류 결과

5-fold 교차 검증 결과:

| 클래스 | Precision | Recall | F1-Score |
|--------|-----------|--------|----------|
| SCUD-B | 1.00 | 1.00 | 1.00 |
| Nodong | 1.00 | 1.00 | 1.00 |
| KN-23 | 1.00 | 1.00 | 1.00 |
| **평균** | **1.00** | **1.00** | **1.00** |

**혼동 행렬 분석:**
- 발사각 그룹 분리 평가(`eval_by_angle.py`)에서 완벽 분류 달성
- 현재 데이터셋(1500×15)이 잘 분리되는 상태로, 15개 시그니처가 탄종 간 구분에 효과적임을 확인

---

## 10. 결론 및 향후 과제

### 10.1 프로젝트 성과 요약

1. **6DOF 시뮬레이션 완성:** 쿼터니언 기반 완전한 6자유도 시뮬레이터 구현 (박윤준, 정연우)
2. **세 가지 미사일 모델링:** SCUD-B, Nodong, KN-23의 물리적으로 타당한 궤적 생성
3. **FFT 기반 동특성 분석:** 시뮬레이터 검증용 각속도 FFT 구현 (박윤준, 정연우)
4. **레이더 관측 기반 15개 시그니처 설계:** 변인통제된 최종 분류 입력 (김찬진)
5. **RandomForest 분류기 개발:** 발사각 그룹 분리 평가 100% 정확도의 탄종 분류기 구현 (김찬진)
6. **시각화 도구 구축:** 12채널 실시간 모니터링 시스템 (정연우)

### 10.2 한계점

- **실제 데이터 부재:** 시뮬레이션 데이터로만 학습, 실제 레이더 데이터 검증 필요
- **환경 요인 미반영:** 바람, 대기 불안정성 등 미고려
- **단일 레이더 가정:** 다중 센서 융합 미구현
- **KN-23 궤적 고정:** KN-23은 저압궤도(depressed trajectory)로 제어되는 시나리오로 구현되어, 입력 발사각 변화가 SCUD-B/Nodong처럼 직접 반영되지 않음
- **13~15번 시그니처:** 현재 구현에서는 6DOF 내부 상태 기반이며, 실제 레이더 적용 시에는 **비행경로각(γ) 변화율, 곡률, 횟가속도** 등 track 기반 대리변수로 대체하거나, micro-Doppler 등 추가 관측을 가정해야 한다.

### 10.3 향후 연구 방향

1. **딥러닝 적용:** CNN/RNN 기반 시계열 분류
2. **실시간 처리:** 스트리밍 데이터 처리 파이프라인
3. **다중 센서 융합:** 레이더, 적외선, 전자광학 센서 통합
4. **적대적 공격 대응:** 기만 기동에 대한 robustness 강화

### 10.4 프로젝트 성찰: 코딩과 프로그래밍의 차이 (정연우)

> "코딩은 문법을 따르는 것이고, 프로그래밍은 문제를 해결하는 것이다."

이 프로젝트를 통해 단순히 코드를 작성하는 것과 실제 물리 시스템을 구현하는 것의 차이를 체감하였다.

**코딩 수준의 접근:**
```python
# 그냥 공식 구현
def pitch_moment(alpha, q):
    return Cm_alpha * alpha + Cm_q * q
```

**프로그래밍 수준의 접근:**
```python
# 물리적 의미를 고려한 구현
def pitch_moment(alpha, q, V, rho, S, c, cg_position, cp_position):
    q_bar = 0.5 * rho * V**2
    static_margin = (cp_position - cg_position) / c
    if static_margin < 0:
        warnings.warn("정적 불안정! CP가 CG 앞에 있음")
    Cm = Cm_alpha * alpha + Cm_q * (q * c / (2*V))
    return q_bar * S * c * Cm
```

**팀 협업에서의 교훈:**
- **문서화의 중요성:** 변수 명명, 단위 주석이 디버깅 시간을 크게 단축
- **버전 관리:** Git을 통한 변경 이력 추적이 필수적
- **코드 리뷰:** 좌표계 오류 등 논리적 버그를 사전에 발견

---

## 11. 팀원 기여도

| 팀원 | 역할 | 주요 기여 |
|------|------|-----------|
| **박윤준** | 팀장, 물리 모델링 | 6DOF 운동방정식, TVC 시스템, FFT 동특성 분석, 보고서 작성 |
| **정연우** | 시각화, 검증 | 12채널 대시보드, 시스템 정합성 검토, FFT 분석 지원 |
| **김찬진** | 시그니처/ML 파이프라인 | 레이더 관측 기반 15개 시그니처 설계·추출, 데이터셋/정규화 파이프라인 구축, RandomForest 학습·평가 |
| **이준서** | UI/게임화 구현 | React 기반 미사일 식별 게임 UI, 웹 프론트엔드 개발 |

### 협업 도구

- **GitHub:** 버전 관리 및 코드 리뷰
- **Notion:** 문서화 및 진행상황 공유
- **Discord:** 실시간 소통

---

## 12. 오픈소스 참조 및 활용

### 12.1 RocketPy (브라질 대학 연구팀)

**GitHub:** https://github.com/RocketPy-Team/RocketPy

**참조 내용:**
- 대기 모델 (US Standard Atmosphere 1976)
- 공력계수 테이블 보간 방법
- 추력 커브 처리

### 12.2 JSBSim (NASA/Lockheed Martin 기원)

**GitHub:** https://github.com/JSBSim-Team/jsbsim

**참조 내용:**
- 6DOF 운동방정식 구조
- 공력 테이블 형식
- 제어 시스템 구조

**우리 구현과의 차이:**
- JSBSim은 일반 항공기용 → 우리는 탄도미사일 특화
- 연료 소모에 따른 CG 이동 우리가 더 상세히 구현

---

## 13. 학술 문헌 정리 (APA Style)

### 핵심 참고 문헌

1. **Zipfel, P. H.** (2007). *Modeling and Simulation of Aerospace Vehicle Dynamics* (2nd ed.). AIAA Education Series.
   - 쿼터니언 운동학 (Chapter 4)
   - 6DOF 운동방정식 (Chapter 5)

2. **Stevens, B. L., & Lewis, F. L.** (2003). *Aircraft Control and Simulation* (2nd ed.). Wiley.
   - 공력 도함수 정의
   - 제어 시스템 설계

3. **Siouris, G. M.** (2004). *Missile Guidance and Control Systems*. Springer.
   - 유도 법칙
   - TVC 모델링

4. **Fleeman, E. L.** (2012). *Missile Design and System Engineering*. AIAA Education Series.
   - 탄도미사일 성능 파라미터
   - 공력 형상 설계

### 북한 미사일 관련 자료

5. **Schiller, M., & Schmucker, R. H.** (2012). "A Review of the Nodong Missile." *Schmucker Technologie.*
   - Nodong 추력, 질량 데이터

6. **Lewis, J., & Schmerler, D.** (2021). "North Korea's KN-23 Missile." *Arms Control Wonk.*
   - KN-23 저압궤도 특성

### 레이더 기반 분류 및 시그니처 관련 문헌

7. **Singh, U. K., Padmanabhan, V., & Agarwal, A.** (2014). "Dynamic classification of ballistic missiles using neural networks and hidden Markov models." *Applied Soft Computing*, 19, 280–289.
   - 레이더 직접/파생 파라미터를 입력으로 분류
   - 본 프로젝트의 15개 시그니처 선정 원칙에 참조

8. **JHU APL Technical Digest** (Various). Parametric classification approaches / simulated signature database 기반 분류 모델 구성.
   - 시뮬레이션 데이터 기반 분류기 설계 흐름 참고

9. **Chen, V. C., et al.** (2006). "Micro-Doppler effect in radar: phenomenon, model, and simulation study." *IEEE Transactions on Aerospace and Electronic Systems*.
   - Time-frequency 기반 특징의 조건 민감성 및 계산비용 이슈
   - 본 프로젝트에서 트랙 기반 시그니처를 우선 채택한 근거

---

## 14. 감사의 글

본 프로젝트를 진행하며 도움을 주신 분들께 감사드립니다.

- **지도교수님:** 3DOF 참조 코드 제공 및 물리 모델링 조언
- **RocketPy 개발팀:** 오픈소스 코드 공개
- **JSBSim 커뮤니티:** 6DOF 구현 참고 자료

---
*본 보고서는 2025년 하반기 데이터과학 프로젝트의 최종 결과물입니다.*
