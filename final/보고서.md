# 탄도미사일 6DOF 시뮬레이션 및 FFT 기반 SVM 분류 프로젝트

## 최종 보고서

**작성자:** 박윤준  
**팀원:** 정연우, 김찬진, 이준서  
**프로젝트 기간:** 2025년 하반기

---

## 목차

1. [Executive Summary](#1-executive-summary)
2. [연구 배경 및 동기](#2-연구-배경-및-동기)
3. [3DOF에서 6DOF로의 전환 과정](#3-3dof에서-6dof로의-전환-과정)
4. [TVC 및 공력 모멘트 구현](#4-tvc-및-공력-모멘트-구현)
5. [KN-23 저압궤도 구현](#5-kn-23-저압궤도-depressed-trajectory-구현)
6. [어려웠던 점 및 해결 방법](#6-어려웠던-점-및-해결-방법)
7. [시각화 및 시스템 정합성 검토](#7-시각화-및-시스템-정합성-검토-정연우)
8. [프로젝트 성찰](#8-프로젝트-성찰-코딩과-프로그래밍의-차이-정연우)
9. [오픈소스 참조 및 활용](#9-오픈소스-참조-및-활용)
10. [학술 문헌 정리](#10-학술-문헌-정리-apa-style)
11. [미사일 판별을 위한 Signature 물리량 발견](#11-미사일-판별을-위한-signature-물리량-발견)
12. [시그니처 분석 방법 선택](#12-시그니처-분석-방법-선택-정연우-김찬진)
13. [결론 및 향후 과제](#13-결론-및-향후-과제)
14. [팀원 기여도](#14-팀원-기여도)
15. [감사의 글](#15-감사의-글)

---

## 1. Executive Summary

본 프로젝트는 SCUD-B, Nodong, KN-23 세 가지 탄도미사일의 비행 궤적을 6자유도(6DOF) 물리 시뮬레이션으로 구현하고, 각속도 데이터의 FFT 분석을 통해 SVM 기반 기계학습 분류기를 개발하는 것을 목표로 한다. 초기 3DOF 참조 코드에서 시작하여 완전한 6DOF 쿼터니언 기반 시뮬레이터로 발전시켰으며, 특히 KN-23의 저압궤도(depressed trajectory) 구현에 성공하였다.

### 주요 성과

- **3DOF → 6DOF 전환 완료** (쿼터니언 기반 자세 표현)
- **200-690km 사거리 달성** (물리적으로 타당한 궤적)
- **0.3-1.5 Hz 대역 각속도 진동 생성** (FFT 분류 가능)
- **TVC 및 공력 모멘트 통합 제어 시스템 구현**
- **12채널 실시간 시각화 보드 구축** (정연우)

---

## 2. 연구 배경 및 동기

### 2.1 문제 정의

탄도미사일의 종류를 레이더 관측 데이터만으로 분류하는 것은 국방 및 전략적으로 중요한 과제이다. 본 프로젝트는 다음과 같은 접근을 시도한다:

- **물리 기반 시뮬레이션:** 실제 미사일의 추력, 질량, 공력계수 등을 학술 문헌에서 검증된 값으로 구현
- **Signature 추출:** 피치/요/롤 각속도의 주파수 특성을 FFT로 분석
- **기계학습 분류:** SVM을 이용하여 미사일 종류 판별

### 2.2 3DOF의 한계

교수님께서 제공하신 초기 3DOF 참조 코드는 질점 모델로, 다음과 같은 한계가 있었다:

| 한계점 | 설명 |
|--------|------|
| **자세 정보 없음** | 각속도, 각가속도 계산 불가 |
| **제어 시스템 부재** | TVC나 공력 핀의 모멘트 효과를 모델링할 수 없음 |
| **FFT 분석 불가능** | 각속도 진동이 없어 주파수 특성 추출 불가능 |

따라서 **6DOF로의 전환이 필수적**이었다.

---

## 3. 3DOF에서 6DOF로의 전환 과정

### 3.0 교수님 3DOF 코드에서 6DOF로 확장: 신규 도입 물리량 정리

**교수님 3DOF 참조 코드가 가진 것:**
- 위치 (x, y, z) - 3개
- 속도 (vx, vy, vz) - 3개
- 질량 (m) - 1개
- **총 7개 상태변수** (질점 모델)

**우리가 6DOF로 확장하며 새로 추가한 물리량:**

#### A. 자세 표현 (Attitude Representation)

| 구분 | 3DOF | 6DOF |
|------|------|------|
| 자세 | 없음 (질점이므로 방향 개념 없음) | 쿼터니언 (q0, q1, q2, q3) - **4개 추가** |

- 이것이 가장 근본적인 차이
- 미사일이 "어느 방향을 향하는가"를 표현
- 초기에 오일러각(ψ, θ, φ)으로 시도했으나 89.5° 문제로 쿼터니언 채택

#### B. 각속도 (Angular Velocity)

| 구분 | 3DOF | 6DOF |
|------|------|------|
| 각속도 | 없음 | (p, q, r) - Body축 각속도 **3개 추가** |

- **p:** Roll rate (x축 회전)
- **q:** Pitch rate (y축 회전)
- **r:** Yaw rate (z축 회전)
- **이게 FFT 분석의 핵심 신호!**

#### C. 관성 모멘트 (Moment of Inertia)

```python
# 3DOF에는 없던 계산
def Iyy(t):  
    m_prop = m_prop_0 * (1 - t/burn_time)
    x_cg = calculate_cg(m_prop)
    # 평행축 정리 적용
    I = I_about_cg + m * d**2
    return I
```

#### D. 모멘트 (Moments about Body Axes)

- **L:** Rolling moment (Roll을 일으키는 모멘트)
- **M:** Pitching moment (Pitch를 일으키는 모멘트)
- **N:** Yawing moment (Yaw를 일으키는 모멘트)

**모멘트 구성요소:**
- 공력 모멘트: `M_aero = q_dynamic × S_ref × c × C_m`
- TVC 모멘트: `M_tvc = Thrust × δ_tvc × L_arm`
- 자이로 모멘트: (회전 중 관성축 변화)

#### E. 공력계수의 확장

| 3DOF | 6DOF |
|------|------|
| C_D(Mach) 정도만 | C_m_alpha, C_m_q, C_m_delta, C_n_beta, C_l_beta 추가 |

#### F. 좌표 변환 행렬

```python
# 3DOF에는 없던 변환
F_body = DCM_NB @ F_inertial  # NED → Body
F_inertial = DCM_BN @ F_body  # Body → NED

# DCM은 쿼터니언에서 계산
DCM = quaternion_to_dcm(q0, q1, q2, q3)
```

#### G. 제어 시스템 (TVC Actuator)

```python
class TVCActuator:  # 3DOF에는 전혀 없던 것
    def __init__(self):
        self.max_deflection = 10  # degrees
        self.time_constant = 0.05  # seconds
        self.rate_limit = 75  # deg/s
```

#### H. 각운동 방정식 (Euler's Equations)

```
Ixx·dp/dt + (Izz - Iyy)·q·r = L
Iyy·dq/dt + (Ixx - Izz)·r·p = M  
Izz·dr/dt + (Iyy - Ixx)·p·q = N
```

### 요약: 상태변수 개수 비교

| 상태변수 | 3DOF | 6DOF | 차이 |
|----------|------|------|------|
| 위치 (x,y,z) | 3 | 3 | 0 |
| 속도 (vx,vy,vz) | 3 | 3 | 0 |
| 쿼터니언 (q0,q1,q2,q3) | 0 | 4 | **+4** |
| 각속도 (p,q,r) | 0 | 3 | **+3** |
| 질량 (m) | 1 | 1 | 0 |
| **총계** | **7** | **14** | **+7** |

### 핵심 통찰

> 3DOF → 6DOF 전환의 본질은 **"방향"과 "회전"의 추가**이다:
> - **3DOF:** "어디에 있는가?" (위치, 속도)
> - **6DOF:** "어디에 있고, 어느 방향을 향하며, 얼마나 빠르게 회전하는가?" (위치, 속도, 자세, 각속도)

이 7개의 추가 상태변수가 **FFT 기반 미사일 분류를 가능**하게 한다.

### 3.1 핵심 물리량 추가

#### 3.1.1 회전 운동학 (Rotational Kinematics)

**오일러각 vs 쿼터니언 선택 과정:**

초기에는 오일러각(Euler angles) 사용을 고려하였다. Zipfel (2007)의 문헌에 따르면:

> "For initialization, we need to express the quaternion components in terms of Euler angles because who wants to describe the launch attitude of a missile in quaternions." (p. 126)

**최종 결정 - 쿼터니언을 선택한 이유:**
- **수치 안정성:** 4차 미분방정식이 선형이며 특이점 없음
- **단위 norm 유지:** 정규화가 용이하여 긴 시뮬레이션에서도 정확도 유지
- **확장성:** 향후 스핀 안정화 미사일이나 극단적 기동에 대응 가능

**쿼터니언 미분방정식 (Zipfel, 2007, Eq. 4.77):**

```
dq₀/dt = -0.5(p·q₁ + q·q₂ + r·q₃)
dq₁/dt =  0.5(p·q₀ + r·q₂ - q·q₃)
dq₂/dt =  0.5(q·q₀ - r·q₁ + p·q₃)
dq₃/dt =  0.5(r·q₀ + q·q₁ - p·q₂)
```

#### 3.1.2 회전 동역학 (Rotational Dynamics)

**오일러 방정식 (Stevens & Lewis, 2003):**

```
Iₓₓ·dp/dt + (Izz - Iyy)·q·r = L_aero + L_tvc
Iyy·dq/dt + (Ixx - Izz)·r·p = M_aero + M_tvc
Izz·dr/dt + (Iyy - Ixx)·p·q = N_aero + N_tvc
```

**핵심 도전 과제: 관성 모멘트의 시간 변화**

```python
def Iyy(self, t):  # Pitch moment of inertia
    m_prop = max(0, self.m_prop_0 * (1 - t/self.tb))
    x_cg = self.cg(t)
    L_prop = self.L - self.L_wh - 0.35
    
    I_wh = (3/80)*self.m_wh*(4*self.r**2 + self.L_wh**2) + \
           self.m_wh*(self.x_cg_wh - x_cg)**2
    I_prop = (1/12)*m_prop*(3*self.r**2 + L_prop**2) + \
             m_prop*(self.x_cg_prop - x_cg)**2
    I_struct = (1/12)*(self.m_dry-self.m_wh)*(3*self.r**2 + L_prop**2)
    
    return I_wh + I_prop + I_struct
```

### 3.2 좌표계 구성

다음 세 가지 좌표계를 사용하였다:

1. **관성 좌표계 (Inertial Frame):** 평면 지구 근사, NED (North-East-Down)
2. **동체 좌표계 (Body Frame):** 미사일 중심축을 x축으로 하는 우수 좌표계
3. **속도 좌표계 (Wind Frame):** 상대 속도 벡터를 x축으로 하는 좌표계

**Direction Cosine Matrix (DCM) - Zipfel, 2007, Eq. 4.80:**

```
C_BN = [q₀²+q₁²-q₂²-q₃²    2(q₁q₂-q₀q₃)      2(q₁q₃+q₀q₂)   ]
       [2(q₁q₂+q₀q₃)        q₀²-q₁²+q₂²-q₃²    2(q₂q₃-q₀q₁)   ]
       [2(q₁q₃-q₀q₂)        2(q₂q₃+q₀q₁)      q₀²-q₁²-q₂²+q₃²]
```
---

## 4. TVC 및 공력 모멘트 구현

### 4.1 TVC (Thrust Vector Control) 시스템

#### 4.1.1 액추에이터 모델링

실제 TVC 시스템의 동역학적 특성을 반영하기 위해 1차 지연 및 Rate Limit을 적용하였다:

```python
class TVCActuator:
    def __init__(self, tau=0.05, max_deflection=10.0, rate_limit=75.0):
        self.tau = tau              # 시정수 [s]
        self.max_deflection = max_deflection  # 최대 편향각 [deg]
        self.rate_limit = rate_limit          # 각속도 제한 [deg/s]
        self.delta = 0.0            # 현재 편향각
        
    def update(self, delta_cmd, dt):
        # 1차 지연 응답
        delta_dot = (delta_cmd - self.delta) / self.tau
        # Rate limiting
        delta_dot = np.clip(delta_dot, -self.rate_limit, self.rate_limit)
        # 적분
        self.delta += delta_dot * dt
        # Saturation
        self.delta = np.clip(self.delta, -self.max_deflection, self.max_deflection)
        return self.delta
```

#### 4.1.2 TVC 모멘트 계산

```python
def tvc_moment(thrust, delta_pitch, delta_yaw, L_arm):
    """
    thrust: 현재 추력 [N]
    delta_pitch, delta_yaw: TVC 편향각 [rad]
    L_arm: CG에서 노즐까지 거리 [m]
    """
    M_tvc = thrust * np.sin(delta_pitch) * L_arm  # Pitching moment
    N_tvc = thrust * np.sin(delta_yaw) * L_arm    # Yawing moment
    return M_tvc, N_tvc
```

### 4.2 공력 모멘트 (Aerodynamic Moment)

#### 4.2.1 모멘트 계수 정의

공력 모멘트는 다음 계수들로 구성된다:

| 계수 | 의미 | 전형적 값 |
|------|------|-----------|
| Cm_alpha | 받음각에 의한 피칭 모멘트 | -3.0 ~ -8.0 /rad |
| Cm_q | 피치율에 의한 댐핑 | -10 ~ -50 /rad |
| Cn_beta | 옆미끄럼각에 의한 요잉 모멘트 | 1.5 ~ 4.0 /rad |
| Cn_r | 요율에 의한 댐핑 | -5 ~ -20 /rad |

#### 4.2.2 안정성 도함수 (Stability Derivatives)

```python
def calculate_aero_moment(self, alpha, beta, p, q, r, V, rho, S, c, b):
    q_bar = 0.5 * rho * V**2  # 동압
    
    # Pitching moment
    Cm = self.Cm_0 + self.Cm_alpha * alpha + self.Cm_q * (q * c / (2*V))
    M_aero = q_bar * S * c * Cm
    
    # Yawing moment
    Cn = self.Cn_0 + self.Cn_beta * beta + self.Cn_r * (r * b / (2*V))
    N_aero = q_bar * S * b * Cn
    
    # Rolling moment
    Cl = self.Cl_beta * beta + self.Cl_p * (p * b / (2*V))
    L_aero = q_bar * S * b * Cl
    
    return L_aero, M_aero, N_aero
```

### 4.3 제어 루프 통합

PD 제어기를 이용한 자세 제어:

```python
def attitude_controller(theta_cmd, theta, q, Kp=2.0, Kd=0.5):
    """
    theta_cmd: 목표 피치각
    theta: 현재 피치각
    q: 피치율
    """
    error = theta_cmd - theta
    delta_cmd = Kp * error - Kd * q
    return np.clip(delta_cmd, -10, 10)  # TVC 제한
```

---

## 5. KN-23 저압궤도 (Depressed Trajectory) 구현

### 5.1 저압궤도의 물리적 특성

KN-23은 기존 탄도미사일과 달리 **최대 고도를 낮추고 비행 시간을 단축**하는 저압궤도를 사용한다:

| 특성 | 일반 탄도궤도 | 저압궤도 (KN-23) |
|------|---------------|-------------------|
| 최대 고도 | ~150 km | ~50 km |
| 비행 시간 | ~500 s | ~300 s |
| 발사각 | 45-60° | 20-30° |
| 종말 속도 | ~2 km/s | ~3 km/s |

### 5.2 구현상의 도전과 해결

#### 5.2.1 문제: 과도한 공력 가열

저고도 비행으로 인해 대기 밀도가 높아 공력 저항과 가열이 증가:

```python
# 해결: 밀도 변화를 고려한 동적 비행 경로 최적화
def optimize_trajectory(self, target_range):
    # 밀도가 낮은 고도대를 찾아 비행
    optimal_alt = self.find_optimal_cruise_altitude(target_range)
    # Pull-up 기동 타이밍 최적화
    pullup_time = self.calculate_pullup_timing(optimal_alt, target_range)
    return optimal_alt, pullup_time
```

#### 5.2.2 문제: Pull-up 기동의 안정성

급격한 자세 변환 시 각속도 진동 발생:

```python
# 해결: 부드러운 경로 전환 (S-curve 프로파일)
def smooth_pullup(self, t, t_start, duration):
    tau = (t - t_start) / duration
    if tau < 0: return 0
    if tau > 1: return 1
    # S-curve (5차 다항식)
    return 10*tau**3 - 15*tau**4 + 6*tau**5
```

### 5.3 검증 결과

시뮬레이션 결과 KN-23의 주요 특성이 재현되었다:

- **사거리:** 450 km (목표: 450 km)
- **최대 고도:** 48.7 km (목표: ~50 km)
- **비행 시간:** 287 s
- **종말 속도:** 2.89 km/s

---

## 6. 어려웠던 점 및 해결 방법

### 6.1 좌표계 혼동 문제

#### 문제 상황
NED, ENU, Body 좌표계 간의 변환에서 지속적으로 부호 오류 발생.

#### 해결 방법

```python
# 명확한 변환 함수 정의
def ned_to_body(vec_ned, dcm_bn):
    """NED 좌표계 벡터를 Body 좌표계로 변환"""
    return dcm_bn @ vec_ned

def body_to_ned(vec_body, dcm_bn):
    """Body 좌표계 벡터를 NED 좌표계로 변환"""
    return dcm_bn.T @ vec_body  # DCM의 전치 = 역행렬

# 모든 변환에 일관된 명명 규칙 적용:
# dcm_AB: A에서 B로의 변환 행렬
```

### 6.2 수치 불안정성

#### 문제 상황
RK4 적분 시 쿼터니언 norm이 발산하는 현상.

#### 해결 방법

```python
# 매 스텝마다 쿼터니언 정규화
def normalize_quaternion(q):
    norm = np.sqrt(q[0]**2 + q[1]**2 + q[2]**2 + q[3]**2)
    if norm < 1e-10:
        return np.array([1, 0, 0, 0])  # 안전한 기본값
    return q / norm

# RK4 후 정규화 적용
q_new = rk4_step(q, dq_dt, dt)
q_new = normalize_quaternion(q_new)
```

### 6.3 공력계수 튜닝

#### 문제 상황
문헌값 그대로 적용 시 시스템이 과도하게 안정하거나 불안정.

#### 해결 방법: 체계적 튜닝 프로세스

1. **1단계:** Cm_alpha만 활성화하여 정적 안정성 확인
2. **2단계:** Cm_q (댐핑) 추가하여 진동 감쇠 확인
3. **3단계:** 교차 커플링 항목 (Cn_beta 등) 점진적 추가

```python
# 튜닝 로그 예시
# Cm_alpha = -5.0: 너무 안정, 응답 느림
# Cm_alpha = -2.0: 적절한 응답
# Cm_q = -30: 과도한 댐핑
# Cm_q = -15: 적절한 댐핑 (0.7 damping ratio 목표)
```

### 6.4 89.5° 피치각 문제 (Gimbal Lock)

#### 문제 상황
발사 초기 피치각이 89.5°일 때 오일러각 특이점 근접.

#### 해결 방법
쿼터니언 기반 구현으로 전환:

```python
# 오일러각에서 쿼터니언으로 초기화
def euler_to_quaternion(psi, theta, phi):
    """
    psi: Yaw, theta: Pitch, phi: Roll [rad]
    """
    cy, sy = np.cos(psi/2), np.sin(psi/2)
    cp, sp = np.cos(theta/2), np.sin(theta/2)
    cr, sr = np.cos(phi/2), np.sin(phi/2)
    
    q0 = cy*cp*cr + sy*sp*sr
    q1 = cy*cp*sr - sy*sp*cr
    q2 = cy*sp*cr + sy*cp*sr
    q3 = sy*cp*cr - cy*sp*sr
    
    return np.array([q0, q1, q2, q3])
```

### 6.5 시뮬레이션과 관측의 괴리

#### 문제 상황
시뮬레이션에서 계산한 각속도를 실제 레이더가 관측할 수 있는지 불명확.

#### 해결 방법
관측 가능한 물리량으로 변환:

```python
# 레이더 관측 가능 각도로 변환
def simulate_radar_observation(state, radar_pos):
    """
    시뮬레이션 상태에서 레이더가 관측할 수 있는 값 추출
    """
    # 위치, 속도 (직접 관측 가능)
    range_vec = state['pos'] - radar_pos
    range_rate = np.dot(state['vel'], range_vec) / np.linalg.norm(range_vec)
    
    # 각속도는 도플러 변조나 표적 크기 변화로 간접 추정
    # 이 부분이 실제 운용에서의 핵심 도전
    return {
        'range': np.linalg.norm(range_vec),
        'range_rate': range_rate,
        'azimuth': np.arctan2(range_vec[1], range_vec[0]),
        'elevation': np.arcsin(-range_vec[2] / np.linalg.norm(range_vec))
    }
```

---

## 7. 시각화 및 시스템 정합성 검토 (정연우)

### 7.1 12채널 실시간 시각화 대시보드

디버깅 및 검증을 위해 12개 채널의 실시간 시각화 시스템을 구축하였다:

| 채널 | 물리량 | 목적 |
|------|--------|------|
| 1-3 | 위치 (x, y, z) | 궤적 추적 |
| 4-6 | 속도 (vx, vy, vz) | 운동 상태 확인 |
| 7-9 | 오일러각 (ψ, θ, φ) | 자세 변화 모니터링 |
| 10-12 | 각속도 (p, q, r) | FFT 분석용 신호 확인 |

### 7.2 시스템 정합성 검토 항목

```python
class SystemValidator:
    def check_consistency(self, state):
        checks = {
            'quaternion_norm': abs(np.linalg.norm(state['q']) - 1.0) < 1e-6,
            'energy_conservation': self.check_energy(state),
            'velocity_consistency': self.check_velocity(state),
            'attitude_velocity_match': self.check_attitude_velocity(state)
        }
        return all(checks.values()), checks
```

---

## 8. 프로젝트 성찰: 코딩과 프로그래밍의 차이 (정연우)

### 8.1 깨달은 점

> "코딩은 문법을 따르는 것이고, 프로그래밍은 문제를 해결하는 것이다."

이 프로젝트를 통해 단순히 코드를 작성하는 것과 실제 물리 시스템을 구현하는 것의 차이를 체감하였다.

### 8.2 구체적 사례

**코딩 수준의 접근:**
```python
# 그냥 공식 구현
def pitch_moment(alpha, q):
    return Cm_alpha * alpha + Cm_q * q
```

**프로그래밍 수준의 접근:**
```python
# 물리적 의미를 고려한 구현
def pitch_moment(alpha, q, V, rho, S, c, cg_position, cp_position):
    """
    alpha: 받음각 [rad] - 양력 방향 결정
    q: 피치율 [rad/s] - 댐핑 효과
    V: 속도 [m/s] - 동압 계산에 필요
    cg_position, cp_position: 안정성 여유 계산
    """
    q_bar = 0.5 * rho * V**2
    static_margin = (cp_position - cg_position) / c
    
    # 정적 안정성 체크
    if static_margin < 0:
        warnings.warn("정적 불안정! CP가 CG 앞에 있음")
    
    Cm = Cm_alpha * alpha + Cm_q * (q * c / (2*V))
    return q_bar * S * c * Cm
```

### 8.3 팀 협업에서의 교훈

- **문서화의 중요성:** 변수 명명, 단위 주석이 디버깅 시간을 크게 단축
- **버전 관리:** Git을 통한 변경 이력 추적이 필수적
- **코드 리뷰:** 좌표계 오류 등 논리적 버그를 사전에 발견

---

## 9. 오픈소스 참조 및 활용

### 9.1 RocketPy (브라질 대학 연구팀)

**GitHub:** https://github.com/RocketPy-Team/RocketPy

**참조 내용:**
- 대기 모델 (US Standard Atmosphere 1976)
- 공력계수 테이블 보간 방법
- 추력 커브 처리

**활용 방법:**
```python
# RocketPy의 대기 모델 참조
class Atmosphere:
    def __init__(self):
        # US Standard Atmosphere 1976 데이터
        self.h_table = [0, 11000, 20000, 32000, 47000, ...]
        self.T_table = [288.15, 216.65, 216.65, 228.65, ...]
        
    def properties(self, h):
        T = np.interp(h, self.h_table, self.T_table)
        # ... 밀도, 압력 계산
        return rho, P, T, a
```

### 9.2 JSBSim (NASA/Lockheed Martin 기원)

**GitHub:** https://github.com/JSBSim-Team/jsbsim

**참조 내용:**
- 6DOF 운동방정식 구조
- 공력 테이블 형식
- 제어 시스템 구조

**우리 구현과의 차이:**
- JSBSim은 일반 항공기용 → 우리는 탄도미사일 특화
- 연료 소모에 따른 CG 이동 우리가 더 상세히 구현

---

## 10. 학술 문헌 정리 (APA Style)

### 핵심 참고 문헌

1. **Zipfel, P. H.** (2007). *Modeling and Simulation of Aerospace Vehicle Dynamics* (2nd ed.). AIAA Education Series.
   - 쿼터니언 운동학 (Chapter 4)
   - 6DOF 운동방정식 (Chapter 5)

2. **Stevens, B. L., & Lewis, F. L.** (2003). *Aircraft Control and Simulation* (2nd ed.). Wiley.
   - 공력 도함수 정의
   - 제어 시스템 설계

3. **Siouris, G. M.** (2004). *Missile Guidance and Control Systems*. Springer.
   - 유도 법칙
   - TVC 모델링

4. **Fleeman, E. L.** (2012). *Missile Design and System Engineering*. AIAA Education Series.
   - 탄도미사일 성능 파라미터
   - 공력 형상 설계

### 북한 미사일 관련 자료

5. **Schiller, M., & Schmucker, R. H.** (2012). "A Review of the Nodong Missile." *Schmucker Technologie.*
   - Nodong 추력, 질량 데이터

6. **Lewis, J., & Schmerler, D.** (2021). "North Korea's KN-23 Missile." *Arms Control Wonk.*
   - KN-23 저압궤도 특성

---

## 11. 미사일 판별을 위한 Signature 물리량 발견

### 11.1 FFT 분석 기반 접근

각속도 시계열 데이터에서 FFT를 수행하여 주파수 영역 특성을 추출:

```python
def extract_fft_features(angular_velocity, dt):
    """
    각속도 시계열에서 FFT 특성 추출
    """
    N = len(angular_velocity)
    freq = np.fft.fftfreq(N, dt)
    fft_result = np.fft.fft(angular_velocity)
    magnitude = np.abs(fft_result)
    
    # 0.3-1.5 Hz 대역 분석
    band_mask = (freq > 0.3) & (freq < 1.5)
    band_power = np.sum(magnitude[band_mask]**2)
    dominant_freq = freq[band_mask][np.argmax(magnitude[band_mask])]
    
    return {
        'band_power': band_power,
        'dominant_freq': dominant_freq,
        'spectral_entropy': calculate_entropy(magnitude[band_mask])
    }
```

### 11.2 추출된 9개 Signature 특성

| # | 특성명 | 물리적 의미 | 단위 |
|---|--------|-------------|------|
| 1 | natural_freq | 피치 고유진동수 | Hz |
| 2 | damping_ratio | 감쇠비 | - |
| 3 | roll_yaw_coupling | 롤-요 커플링 강도 | - |
| 4 | max_pitch_rate | 최대 피치율 | deg/s |
| 5 | pitch_energy | 피치 진동 에너지 | (deg/s)² |
| 6 | trajectory_curvature | 궤적 곡률 | 1/km |
| 7 | apogee_time_ratio | 정점까지 시간 비율 | - |
| 8 | terminal_dive_angle | 종말 강하각 | deg |
| 9 | velocity_at_apogee | 정점 속도 비율 | - |

### 11.3 미사일별 특성 차이

| 미사일 | 고유진동수 | 감쇠비 | 궤적 곡률 |
|--------|-----------|--------|-----------|
| SCUD-B | 0.45 Hz | 0.65 | 낮음 |
| Nodong | 0.38 Hz | 0.72 | 중간 |
| KN-23 | 0.82 Hz | 0.55 | 높음 (저압궤도) |

---

## 12. 시그니처 분석 방법 선택 (정연우, 김찬진)

### 12.1 SVM 선택 이유

여러 분류 알고리즘을 비교 검토하였다:

| 알고리즘 | 장점 | 단점 | 선택 여부 |
|----------|------|------|-----------|
| **SVM** | 고차원에서 효과적, 작은 데이터셋에 강함 | 대규모 데이터 느림 | ✓ 선택 |
| Random Forest | 해석 용이 | 과적합 위험 | - |
| Neural Network | 비선형 패턴 학습 | 데이터 많이 필요 | - |
| k-NN | 구현 간단 | 차원의 저주 | - |

### 12.2 SVM 구현

```python
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import cross_val_score

class MissileClassifier:
    def __init__(self):
        self.scaler = StandardScaler()
        self.svm = SVC(kernel='rbf', C=10, gamma='scale')
        
    def train(self, X, y):
        X_scaled = self.scaler.fit_transform(X)
        self.svm.fit(X_scaled, y)
        
        # 교차 검증
        scores = cross_val_score(self.svm, X_scaled, y, cv=5)
        print(f"Cross-validation accuracy: {scores.mean():.2f} ± {scores.std():.2f}")
        
    def predict(self, X):
        X_scaled = self.scaler.transform(X)
        return self.svm.predict(X_scaled)
```

### 12.3 분류 결과

5-fold 교차 검증 결과:

| 클래스 | Precision | Recall | F1-Score |
|--------|-----------|--------|----------|
| SCUD-B | 0.94 | 0.92 | 0.93 |
| Nodong | 0.91 | 0.93 | 0.92 |
| KN-23 | 0.97 | 0.96 | 0.96 |
| **평균** | **0.94** | **0.94** | **0.94** |

**혼동 행렬 분석:**
- SCUD-B와 Nodong 간 오분류 일부 발생 (유사한 궤적 특성)
- KN-23은 저압궤도로 인해 명확하게 구분됨

---

## 13. 결론 및 향후 과제

### 13.1 프로젝트 성과 요약

1. **6DOF 시뮬레이션 완성:** 쿼터니언 기반 완전한 6자유도 시뮬레이터 구현
2. **세 가지 미사일 모델링:** SCUD-B, Nodong, KN-23의 물리적으로 타당한 궤적 생성
3. **FFT 기반 특성 추출:** 각속도 데이터에서 분류 가능한 9개 특성 도출
4. **SVM 분류기 개발:** 94% 정확도의 미사일 종류 분류기 구현
5. **시각화 도구 구축:** 12채널 실시간 모니터링 시스템

### 13.2 한계점

- **실제 데이터 부재:** 시뮬레이션 데이터로만 학습, 실제 레이더 데이터 검증 필요
- **환경 요인 미반영:** 바람, 대기 불안정성 등 미고려
- **단일 레이더 가정:** 다중 센서 융합 미구현

### 13.3 향후 연구 방향

1. **딥러닝 적용:** CNN/RNN 기반 시계열 분류
2. **실시간 처리:** 스트리밍 데이터 처리 파이프라인
3. **다중 센서 융합:** 레이더, 적외선, 전자광학 센서 통합
4. **적대적 공격 대응:** 기만 기동에 대한 robustness 강화

---

## 14. 팀원 기여도

| 팀원 | 역할 | 주요 기여 |
|------|------|-----------|
| **박윤준** | 팀장, 물리 모델링 | 6DOF 운동방정식, TVC 시스템, 보고서 작성 |
| **정연우** | 시각화, 검증 | 12채널 대시보드, 시스템 정합성 검토, 성찰 |
| **김찬진** | ML 파이프라인 | FFT 특성 추출, SVM 학습, 분류기 최적화 |
| **이준서** | 데이터 생성 | 시뮬레이션 실행, 데이터셋 구축, 전처리 |

### 협업 도구

- **GitHub:** 버전 관리 및 코드 리뷰
- **Notion:** 문서화 및 진행상황 공유
- **Discord:** 실시간 소통

---

## 15. 감사의 글

본 프로젝트를 진행하며 도움을 주신 분들께 감사드립니다.

- **지도교수님:** 3DOF 참조 코드 제공 및 물리 모델링 조언
- **RocketPy 개발팀:** 오픈소스 코드 공개
- **JSBSim 커뮤니티:** 6DOF 구현 참고 자료

---

*본 보고서는 2025년 하반기 데이터과학 프로젝트의 최종 결과물입니다.*